diff -Naur gui_orig/data/keymap.xml gui_new/data/keymap.xml
--- gui_orig/data/keymap.xml	2013-05-14 22:15:18.293070911 +0200
+++ gui_new/data/keymap.xml	2013-05-14 22:15:07.671906836 +0200
@@ -6,15 +6,15 @@
 		</device>
 		<key id="KEY_UP" mapto="moveUp" flags="mr" />
 		<key id="KEY_DOWN" mapto="moveDown" flags="mr" />
-		<key id="KEY_HOME" mapto="moveTop" flags="mr" />
-		<key id="KEY_END" mapto="moveEnd" flags="mr" />
+		<key id="KEY_REWIND" mapto="moveTop" flags="mr" />
+		<key id="KEY_FASTFORWARD" mapto="moveEnd" flags="mr" />
 		<key id="KEY_PAGEUP" mapto="pageUp" flags="mr" />
 		<key id="KEY_PAGEDOWN" mapto="pageDown" flags="mr" />
 		<key id="KEY_LEFT" mapto="pageUp" flags="mr" />
 		<key id="KEY_RIGHT" mapto="pageDown" flags="mr" />
 		
-		<key id="1" mapto="moveUp" flags="mr" />
-		<key id="2" mapto="moveDown" flags="mr" />
+		<key id="KEY_1" mapto="moveUp" flags="mr" />
+		<key id="KEY_2" mapto="moveDown" flags="mr" />
 	</map>
 	
 	<map context="KeyboardInputActions">
@@ -23,36 +23,37 @@
 		<key id="KEY_HOME" mapto="home" flags="mr" />
 		<key id="KEY_END" mapto="end" flags="mr" />
 		<key id="KEY_BACK" mapto="home" flags="mr" />
+		<key id="KEY_ENTER" mapto="ok" flags="mr" />
 		<key id="KEY_FORWARD" mapto="end" flags="mr" />
 		<key id="KEY_DELETE" mapto="deleteForward" flags="mr" />
 		<key id="KEY_BACKSPACE" mapto="deleteBackward" flags="mr" />
 		<key id="KEY_TAB" mapto="tab" flags="mr" />
 		<key id="KEY_INSERT" mapto="toggleOverwrite" flags="m" />
-		<key id="KEY_PAGEUP" mapto="pageUp" flags="mr" />
-		<key id="KEY_PAGEDOWN" mapto="pageDown" flags="mr" />
-		<key id="KEY_CHANNELUP" mapto="pageUp" flags="mr" />
-		<key id="KEY_CHANNELDOWN" mapto="pageDown" flags="mr" />
+		<key id="KEY_1" mapto="1" flags="m" />
+		<key id="KEY_2" mapto="2" flags="m" />
+		<key id="KEY_3" mapto="3" flags="m" />
+		<key id="KEY_4" mapto="4" flags="m" />
+		<key id="KEY_5" mapto="5" flags="m" />
+		<key id="KEY_6" mapto="6" flags="m" />
+		<key id="KEY_7" mapto="7" flags="m" />
+		<key id="KEY_8" mapto="8" flags="m" />
+		<key id="KEY_9" mapto="9" flags="m" />
+		<key id="KEY_0" mapto="0" flags="m" />
 	</map>
 
 	<map context="SetupActions">
 		<key id="KEY_ENTER" mapto="ok" flags="m" />
 		<key id="KEY_OK" mapto="ok" flags="m" />
 		<key id="KEY_EXIT" mapto="cancel" flags="m" />
-		<key id="KEY_ESC" mapto="cancel" flags="m" />
+		<key id="KEY_HOME" mapto="cancel" flags="m" />
 		<key id="KEY_LEFT" mapto="left" flags="mr" />
 		<key id="KEY_RIGHT" mapto="right" flags="mr" />
 		<key id="KEY_RED" mapto="cancel" flags="m" />
 		<key id="KEY_GREEN" mapto="save" flags="m" />
-		<device name="dreambox advanced remote control (native)">
-			<key id="KEY_MUTE" mapto="deleteForward" flags="mr" />
-			<key id="KEY_NEXT" mapto="deleteForward" flags="mr" />
-			<key id="KEY_PREVIOUS" mapto="deleteBackward" flags="mr" />
-		</device>
-		<device name="dreambox remote control (native)">
-			<key id="KEY_MUTE" mapto="deleteForward" flags="mr" />
-			<key id="KEY_NEXT" mapto="deleteForward" flags="mr" />
-			<key id="KEY_PREVIOUS" mapto="deleteBackward" flags="mr" />
-		</device>
+
+		<key id="KEY_FASTFORWARD" mapto="deleteForward" flags="mr" />
+		<key id="KEY_REWIND" mapto="deleteBackward" flags="mr" />
+
 		<key id="KEY_1" mapto="1" flags="m" />
 		<key id="KEY_2" mapto="2" flags="m" />
 		<key id="KEY_3" mapto="3" flags="m" />
@@ -81,40 +82,32 @@
 	</map>
 
 	<map context="InfobarEPGActions">
-		<key id="KEY_INFO" mapto="showEventInfo" flags="b" />
-		<key id="KEY_INFO" mapto="showEventInfoPlugin" flags="l" />
 		<key id="KEY_EPG" mapto="showEventInfo" flags="b" />
 		<key id="KEY_EPG" mapto="showEventInfoPlugin" flags="l" />
 	</map>
 	
 	<map context="InfobarInstantRecord">
 		<key id="KEY_RECORD" mapto="instantRecord" flags="m" />
-		<device name="dreambox remote control (native)">
-			<key id="KEY_RED" mapto="instantRecord" flags="b" />
-		</device>
 	</map>
 
 	<map context="InfobarExtensions">
 		<key id="KEY_RED" mapto="extensions" flags="b" />
 	</map>
-
+	
 	<map context="SatlistShortcutAction">
 		<key id="KEY_BLUE" mapto="nothingconnected" flags="b" />
 	</map>
-
+	
 	<map context="InfobarChannelSelection">
 		<key id="KEY_LEFT" mapto="zapUp" flags="mr" />
 		<key id="KEY_RIGHT" mapto="zapDown" flags="mr" />
+		<key id="KEY_PAGEUP" mapto="zapDown" flags="m" />
+		<key id="KEY_PAGEDOWN" mapto="zapUp" flags="m" />
 		<key id="KEY_UP" mapto="switchChannelUp" flags="mr" />
 		<key id="KEY_DOWN" mapto="switchChannelDown" flags="mr" />
-		<key id="KEY_PREVIOUS" mapto="historyBack" flags="mr" />
-		<key id="KEY_NEXT" mapto="historyNext" flags="mr" />
-		<key id="KEY_BACK" mapto="historyBack" flags="mr" />
-		<key id="KEY_FORWARD" mapto="historyNext" flags="mr" />
-		<key id="KEY_CHANNELUP" mapto="openServiceList" flags="m" />
-		<key id="KEY_CHANNELDOWN" mapto="openServiceList" flags="m" />
-		<key id="BTN_0" mapto="zapUp" flags="mr" />
-		<key id="BTN_1" mapto="zapDown" flags="mr" />
+		<key id="KEY_REWIND" mapto="historyBack" flags="mr" />
+		<key id="KEY_FASTFORWARD" mapto="historyNext" flags="mr" />
+		<key id="KEY_OK" mapto="openServiceList" flags="m" />
 	</map>
 	
 	<map context="MinuteInputActions">
@@ -123,11 +116,13 @@
 		<key id="KEY_OK" mapto="ok" flags="m" />
 		<key id="KEY_ENTER" mapto="ok" flags="m" />
 		<key id="KEY_EXIT" mapto="cancel" flags="m" />
-		<key id="KEY_ESC" mapto="cancel" flags="m" />
+		<key id="KEY_HOME" mapto="cancel" flags="m" />
 	</map>
 
 	<map context="InputAsciiActions">
-		<key id="KEY_ASCII" mapto="gotAsciiCode" flags="mr" />
+		<device name="Console">
+			<key id="KEY_ASCII" mapto="gotAsciiCode" flags="mr" />
+		</device>
 	</map>
 
 	<map context="InputBoxActions">
@@ -136,17 +131,11 @@
 		<key id="KEY_OK" mapto="ok" flags="m" />
 		<key id="KEY_ENTER" mapto="ok" flags="m" />
 		<key id="KEY_EXIT" mapto="back" flags="m" />
-		<key id="KEY_ESC" mapto="back" flags="m" />
-		<device name="dreambox advanced remote control (native)">
-			<key id="KEY_MUTE" mapto="deleteForward" flags="mr" />
-			<key id="KEY_NEXT" mapto="deleteForward" flags="mr" />
-			<key id="KEY_PREVIOUS" mapto="deleteBackward" flags="mr" />
-		</device>
-		<device name="dreambox remote control (native)">
-			<key id="KEY_MUTE" mapto="deleteForward" flags="mr" />
-			<key id="KEY_NEXT" mapto="deleteForward" flags="mr" />
-			<key id="KEY_PREVIOUS" mapto="deleteBackward" flags="mr" />
-		</device>
+		<key id="KEY_HOME" mapto="back" flags="m" />
+
+		<key id="KEY_FASTFORWARD" mapto="deleteForward" flags="mr" />
+		<key id="KEY_REWIND" mapto="deleteBackward" flags="mr" />
+		
 		<key id="KEY_1" mapto="1" flags="m" />
 		<key id="KEY_2" mapto="2" flags="m" />
 		<key id="KEY_3" mapto="3" flags="m" />
@@ -167,82 +156,61 @@
 		<key id="KEY_OK" mapto="ok" flags="m" />
 		<key id="KEY_ENTER" mapto="ok" flags="m" />
 		<key id="KEY_EXIT" mapto="back" flags="m" />
-		<key id="KEY_ESC" mapto="back" flags="m" />
+		<key id="KEY_HOME" mapto="back" flags="m" />
 	</map>
 	
 	<map context="InfobarMenuActions">
 		<key id="KEY_MENU" mapto="mainMenu" flags="mr" />
-		<key id="KEY_SPACE" mapto="mainMenu" flags="mr" />
 	</map>
 	
 	<map context="MenuActions">
 		<key id="KEY_MENU" mapto="menu" flags="mr" />
-		<key id="KEY_SPACE" mapto="menu" flags="mr" />
 	</map>
 	
 	<map context="InfobarShowHideActions">
-		<key id="KEY_OK" mapto="toggleShow" flags="m" />
+		<key id="KEY_INFO" mapto="toggleShow" flags="m" />
 		<key id="KEY_ENTER" mapto="toggleShow" flags="m" />
 		<key id="KEY_EXIT" mapto="hide" flags="m" />
-		<key id="KEY_ESC" mapto="hide" flags="m" />
+		<key id="KEY_HOME" mapto="hide" flags="m" />
 	</map>
 
 	<map context="InfobarActions">
-		<key id="KEY_VIDEO" mapto="showMovies" flags="b" />
-		<key id="KEY_VIDEO" mapto="showMediaPlayer" flags="l" />
 		<key id="KEY_PLAY" mapto="showMovies" flags="m" />
-		<key id="KEY_RADIO" mapto="toogleTvRadio" flags="b" />
-		<key id="KEY_RADIO" mapto="openBouquetList" flags="l" />
-		<key id="KEY_TV" mapto="toogleTvRadio" flags="b" />
-		<key id="KEY_TV" mapto="openBouquetList" flags="l" />
-		<key id="KEY_FILE" mapto="showMovies" flags="m" />
-		<key id="KEY_LIST" mapto="showMovies" flags="b" />
-		<key id="KEY_PROGRAM" mapto="openTimerList" flags="b" />
-		<key id="KEY_F5" mapto="openTimerList" flags="b" />
-		<key id="KEY_PROGRAM" mapto="openAutoTimerList" flags="l" />
-		<key id="KEY_SEARCH" mapto="openEPGSearch" flags="b" />
-		<key id="KEY_SEARCH" mapto="openIMDB" flags="l" />
-		<key id="KEY_TEXT" mapto="showText" flags="m" />
+		<key id="KEY_ARCHIVE" mapto="showMovies" flags="m" />
+		<key id="KEY_BLUE" mapto="toogleTvRadio" flags="m" />
+		<key id="KEY_TV2" mapto="toogleTvRadio" flags="m" />
+    
+		<!--key id="KEY_BLUE" mapto="showTv" flags="m" /-->
 	</map>
 
-	<map context="InfobarAudioSelectionActions">
-		<key id="KEY_AUDIO" mapto="audioSelection" flags="m" />
-		<device name="dreambox advanced remote control (native)">
-			<key id="KEY_YELLOW" mapto="audioSelection" flags="b" />
-		</device>
-	</map>
+        <map context="InfobarSIFTeamActions">
+                <key id="KEY_YELLOW" mapto="videoselection" flags="b" />
+                <key id="KEY_BLUE" mapto="sifpanel" flags="m" />
+        </map>
 
-	<map context="InfobarSubtitleSelectionActions">
-		<key id="KEY_SUBTITLE" mapto="subtitleSelection" flags="m" />
+	<map context="InfobarExtendedAudioSelectionActions">
+		<key id="KEY_YELLOW" mapto="audioSelection" flags="m" />
 	</map>
 
-	<map context="InfobarSIFTeamActions">
-		<key id="KEY_YELLOW" mapto="videoselection" flags="b" />
-		<key id="KEY_BLUE" mapto="sifpanel" flags="m" />
+	<map context="InfobarAudioSelectionActions">
+		<key id="KEY_YELLOW" mapto="audioSelection" flags="m" />
+		<key id="KEY_LANGUAGE" mapto="audioSelection" flags="m" />
 	</map>
 
+	<map context="InfobarAspectSelectionActions">
+		<key id="KEY_GREEN" mapto="aspectSelection" flags="m" />
+	</map>
 	<map context="InfobarSubserviceSelectionActions">
 		<key id="KEY_GREEN" mapto="subserviceSelection" flags="b" />
 	</map>
 
-	<map context="InfobarRedButtonActions">
-		<device name="dreambox advanced remote control (native)">
-			<key id="KEY_RED" mapto="extensions" flags="b" />
-		</device>
-	</map>
-
-	<map context="InfobarPiPActions">
-		<key id="KEY_SCREEN" mapto="activatePiP" flags="b" />
-	</map>
-
 	<map context="InfobarSubserviceQuickzapActions">
 		<key id="KEY_PREVIOUS" mapto="prevSubservice" flags="m" />
 		<key id="KEY_NEXT" mapto="nextSubservice" flags="m" />
 		<key id="KEY_BACK" mapto="prevSubservice" flags="m" />
 		<key id="KEY_FORWARD" mapto="nextSubservice" flags="m" />
 		<key id="KEY_EXIT" mapto="exit" flags="m" />
-		<key id="KEY_ESC" mapto="exit" flags="m" />
-		<key id="KEY_TV" mapto="exit" flags="m" />
+		<key id="KEY_HOME" mapto="exit" flags="m" />
 	</map>
 
 	<map context="GlobalActions">
@@ -252,10 +220,6 @@
 		<key id="KEY_POWER" mapto="power_long" flags="l" />
 		<key id="KEY_POWER" mapto="power_down" flags="m" />
 		<key id="KEY_POWER" mapto="power_up" flags="b" />
-		<key id="KEY_KP0" mapto="discrete_off" flags="m" />
-		<device name="dreambox front panel">
-			<key id="KEY_POWER" mapto="deepstandby" flags="l" />
-		</device>
 	</map>
 	
 	<map context="PowerKeyActions">
@@ -277,45 +241,20 @@
 	</map>
 
 	<map context="TextEntryActions">
-		<device name="dreambox advanced remote control (native)">
-			<key id="KEY_MUTE" mapto="deleteForward" flags="mr" />
-			<key id="KEY_NEXT" mapto="deleteForward" flags="mr" />
-			<key id="KEY_PREVIOUS" mapto="deleteBackward" flags="mr" />
-		</device>
-		<device name="dreambox remote control (native)">
-			<key id="KEY_MUTE" mapto="deleteForward" flags="mr" />
-			<key id="KEY_NEXT" mapto="deleteForward" flags="mr" />
-			<key id="KEY_PREVIOUS" mapto="deleteBackward" flags="mr" />
-		</device>
+		<key id="KEY_FASTFORWARD" mapto="deleteForward" flags="mr" />
+		<key id="KEY_REWIND" mapto="deleteBackward" flags="mr" />
 	</map>	
 
 	<map context="InfobarSeekActions">
-		<device name="dreambox advanced remote control (native)">
-			<key id="KEY_PREVIOUSSONG" mapto="seekBack" flags="b" />
-			<key id="KEY_NEXTSONG" mapto="seekFwd" flags="b" />
-			<key id="KEY_PREVIOUSSONG" mapto="seekBackManual" flags="l" />
-			<key id="KEY_NEXTSONG" mapto="seekFwdManual" flags="l" />
-		</device>
-		<device name="dreambox remote control (native)">
-			<key id="KEY_YELLOW" mapto="pauseService" flags="b" />
-			<key id="KEY_GREEN" mapto="unPauseService" flags="b" />
-			<key id="KEY_RED" mapto="seekBack" flags="b" />
-			<key id="KEY_BLUE" mapto="seekFwd" flags="b" />
-			<key id="KEY_RED" mapto="seekBackManual" flags="l" />
-			<key id="KEY_BLUE" mapto="seekFwdManual" flags="l" />
-		</device>
-		<key id="KEY_PLAYPAUSE" mapto="playpauseService" flags="m" />
 		<key id="KEY_PAUSE" mapto="pauseService" flags="m" />
-		<key id="KEY_PLAY" mapto="unPauseService" flags="m" />
+		<key id="KEY_PLAY" mapto="playpauseService" flags="m" />
 		<key id="KEY_REWIND" mapto="seekBack" flags="b" />
 		<key id="KEY_FASTFORWARD" mapto="seekFwd" flags="b" />
 		<key id="KEY_REWIND" mapto="seekBackManual" flags="l" />
 		<key id="KEY_FASTFORWARD" mapto="seekFwdManual" flags="l" />
-
-		<device name="dreambox remote control (native)">
-			<key id="KEY_LEFT" mapto="seekBack" flags="m" />
-			<key id="KEY_RIGHT" mapto="seekFwd" flags="m" />
-		</device>
+			
+		<key id="KEY_LEFT" mapto="seekBack" flags="m" />
+		<key id="KEY_RIGHT" mapto="seekFwd" flags="m" />
 
 		<key id="KEY_OK" mapto="unPauseService" flags="m" />
 		
@@ -328,23 +267,11 @@
 	</map>
 
 	<map context="MediaPlayerSeekActions">
-		<device name="dreambox advanced remote control (native)">
-			<key id="KEY_PREVIOUSSONG" mapto="seekBack" flags="b" />
-			<key id="KEY_NEXTSONG" mapto="seekFwd" flags="b" />
-			<key id="KEY_PREVIOUSSONG" mapto="seekBackManual" flags="l" />
-			<key id="KEY_NEXTSONG" mapto="seekFwdManual" flags="l" />
-		</device>
-		<device name="dreambox remote control (native)">
-			<key id="KEY_RED" mapto="seekBack" flags="b" />
-			<key id="KEY_BLUE" mapto="seekFwd" flags="b" />
-			<key id="KEY_RED" mapto="seekBackManual" flags="l" />
-			<key id="KEY_BLUE" mapto="seekFwdManual" flags="l" />
-		</device>
 		<key id="KEY_REWIND" mapto="seekBack" flags="b" />
 		<key id="KEY_FASTFORWARD" mapto="seekFwd" flags="b" />
 		<key id="KEY_REWIND" mapto="seekBackManual" flags="l" />
 		<key id="KEY_FASTFORWARD" mapto="seekFwdManual" flags="l" />
-		
+
 		<key id="KEY_1" mapto="seekdef:1" flags="m" />
 		<key id="KEY_3" mapto="seekdef:3" flags="m" />
 		<key id="KEY_4" mapto="seekdef:4" flags="m" />
@@ -354,88 +281,39 @@
 	</map>
 
 	<map context="InfobarTimeshiftActions">
-		<device name="dreambox remote control (native)">
-			<key id="KEY_YELLOW" mapto="timeshiftStart" flags="b" />
-			<key id="KEY_TV" mapto="timeshiftStop" flags="m" />
-		</device>
-		<device name="dreambox ir keyboard">
-			<key id="KEY_YELLOW" mapto="timeshiftStart" flags="m" />
-		</device>
-		<key id="KEY_PLAYPAUSE" mapto="timeshiftStart" flags="m" />
 		<key id="KEY_PAUSE" mapto="timeshiftStart" flags="m" />
 		<key id="KEY_STOP" mapto="timeshiftStop" flags="m" />
-		<key id="KEY_TIME" mapto="timeshiftStart" flags="m" />
 	</map>
 
 	<map context="InfobarTimeshiftActivateActions">
-		<device name="dreambox advanced remote control (native)">
-			<key id="KEY_PREVIOUSSONG" mapto="timeshiftActivateEnd" flags="m" />
-		</device>
-		<device name="dreambox remote control (native)">
-			<key id="KEY_RED" mapto="timeshiftActivateEnd" flags="b" />
-			<key id="KEY_YELLOW" mapto="timeshiftActivateEndAndPause" flags="b" />
-		</device>
-		<key id="KEY_PLAYPAUSE" mapto="timeshiftActivateEndAndPause" flags="m" />
+		<key id="KEY_STOP" mapto="timeshiftActivateEnd" flags="m" />
 		<key id="KEY_PAUSE" mapto="timeshiftActivateEndAndPause" flags="m" />
-		<key id="KEY_REWIND" mapto="timeshiftActivateEnd" flags="m" />
 	</map>
 
 	<map context="MovieSelectionActions">
 		<key id="KEY_MENU" mapto="contextMenu" flags="m" />
-		<key id="KEY_SPACE" mapto="contextMenu" flags="m" />
 		<key id="KEY_INFO" mapto="showEventInfo" flags="m" />
 	</map>
 
 	<map context="InfobarMovieListActions">
 		<key id="KEY_UP" mapto="up" flags="m" />
 		<key id="KEY_DOWN" mapto="down" flags="m" />
-		<key id="KEY_VIDEO" mapto="movieList" flags="m" />
-		<key id="KEY_FILE" mapto="movieList" flags="m" />
+		<key id="KEY_EPG" mapto="movieList" flags="m" />
 	</map>
 
 	<map context="MoviePlayerActions">
-		<key id="KEY_TV" mapto="leavePlayer" flags="m" />
 		<key id="KEY_STOP" mapto="leavePlayer" flags="m" />
-		<key id="KEY_BACK" mapto="leavePlayer" flags="m" />
-		<key id="KEY_EXIT" mapto="leavePlayerOnExit" flags="m" />
-		<key id="KEY_ESC" mapto="leavePlayerOnExit" flags="m" />
-		<key id="KEY_CHANNELUP" mapto="channelUp" flags="m" />
-		<key id="KEY_CHANNELDOWN" mapto="channelDown" flags="m" />
-		<key id="KEY_PREVIOUS" mapto="movePrev" flags="b" />
-		<key id="KEY_NEXT" mapto="moveNext" flags="b" />
-		<key id="KEY_AUDIO" mapto="AudioSelection" flags="m" />
 	</map>
 	
 	<map context="InfobarCueSheetActions">
-		<device name="dreambox advanced remote control (native)">
-			<key id="KEY_PREVIOUS" mapto="jumpPreviousMark" flags="m" />
-			<key id="KEY_0" mapto="toggleMark" flags="m" />
-			<key id="KEY_NEXT" mapto="jumpNextMark" flags="m" />
-		</device>
-		<device name="dreambox remote control (native)">
-			<key id="KEY_PREVIOUS" mapto="jumpPreviousMark" flags="m" />
-			<key id="KEY_NEXT" mapto="jumpNextMark" flags="m" />
-			<key id="KEY_0" mapto="toggleMark" flags="m" />
-		</device>
-		<device name="dreambox ir keyboard">
-			<key id="KEY_PREVIOUSSONG" mapto="jumpPreviousMark" flags="m" />
-			<key id="KEY_TAB" mapto="toggleMark" flags="m" />
-			<key id="KEY_NEXTSONG" mapto="jumpNextMark" flags="m" />
-		</device>
+		<key id="KEY_LEFT" mapto="jumpPreviousMark" flags="m" />
+		<key id="KEY_0" mapto="toggleMark" flags="m" />
+		<key id="KEY_RIGHT" mapto="jumpNextMark" flags="m" />
 	</map>
 	
 	<map context="MediaPlayerCueSheetActions">
-		<device name="dreambox advanced remote control (native)">
 			<key id="KEY_0" mapto="toggleMark" flags="m" />
-		</device>
-		<device name="dreambox remote control (native)">
-			<key id="KEY_0" mapto="toggleMark" flags="m" />
-		</device>
-		<device name="dreambox ir keyboard">
-			<key id="KEY_TAB" mapto="toggleMark" flags="m" />
-		</device>
 	</map>
-
 	<map context="VirtualKeyboardActions">
 		<key id="KEY_TEXT" mapto="showVirtualKeyboard" flags="m" />
 	</map>
@@ -453,7 +331,7 @@
 		<key id="KEY_RIGHT" mapto="nextSubPage" flags="mr" />
 		<key id="KEY_UP" mapto="prevPage" flags="mr" />
 		<key id="KEY_DOWN" mapto="nextPage" flags="mr" />
-		<key id="KEY_EXIT" mapto="exit" flags="m" />
+		<key id="KEY_HOME" mapto="exit" flags="m" />
 		<key id="KEY_ESC" mapto="exit" flags="m" />
 	</map>
 
@@ -462,25 +340,22 @@
 		<key id="KEY_GREEN" mapto="showSatellites" flags="m" />
 		<key id="KEY_YELLOW" mapto="showProviders" flags="m" />
 		<key id="KEY_BLUE" mapto="showFavourites" flags="m" />
-		<key id="KEY_CHANNELUP" mapto="nextBouquet" flags="m" />
-		<key id="KEY_CHANNELDOWN" mapto="prevBouquet" flags="m" />
-		<key id="KEY_PREVIOUS" mapto="prevMarker" flags="m" />
-		<key id="KEY_NEXT" mapto="nextMarker" flags="m" />
-		<key id="KEY_BACK" mapto="prevMarker" flags="m" />
-		<key id="KEY_FORWARD" mapto="nextMarker" flags="m" />
+		<key id="KEY_FAVORITES" mapto="showFavourites" flags="m" />
+		<key id="KEY_REWIND" mapto="prevBouquet" flags="m" />
+		<key id="KEY_FASTFORWARD" mapto="nextBouquet" flags="m" />
 	</map>
 
 	<map context="ChannelSelectEPGActions">
-		<key id="KEY_INFO" mapto="showEPGList" flags="m" />
 		<key id="KEY_EPG" mapto="showEPGList" flags="m" />
 	</map>
 
 	<map context="ChannelSelectEditActions">
 		<key id="KEY_MENU" mapto="contextMenu" flags="m" />
-		<key id="KEY_SPACE" mapto="contextMenu" flags="m" />
 	</map>
 
 	<map context="TvRadioActions">
+		<key id="KEY_0" mapto="keyTV" flags="m" />
+		<key id="KEY_TEXT" mapto="keyRadio" flags="m" />
 		<key id="KEY_TV" mapto="keyTV" flags="m" />
 		<key id="KEY_RADIO" mapto="keyRadio" flags="m" />
 	</map>
@@ -494,15 +369,12 @@
 		<key id="KEY_YELLOW" mapto="yellow" flags="mr" />
 		<key id="KEY_BLUE" mapto="blue" flags="mr" />
 		<key id="KEY_RED" mapto="red" flags="m" />
-		<key id="KEY_INFO" mapto="info" flags="m" />
 		<key id="KEY_EPG" mapto="info" flags="m" />
-		<key id="KEY_MENU" mapto="menu" flags="m" />
+		<key id="KEY_MENU" mapto="input_date_time" flags="m" />
 		<key id="KEY_CHANNELUP" mapto="nextBouquet" flags="m" />
 		<key id="KEY_CHANNELDOWN" mapto="prevBouquet" flags="m" />
 		<key id="KEY_NEXT" mapto="nextService" flags="m" />
 		<key id="KEY_PREVIOUS" mapto="prevService" flags="m" />
-		<key id="KEY_PROGRAM" mapto="timerAdd" flags="m" />
-		<key id="KEY_TV" mapto="preview" flags="m" />
 	</map>
 
 	<map context="EventViewActions">
@@ -512,27 +384,20 @@
 		<key id="KEY_RIGHT" mapto="nextEvent" flags="mr" />
 		<key id="KEY_RED" mapto="openSimilarList" flags="m" />
 		<key id="KEY_GREEN" mapto="timerAdd" flags="m" />
-		<key id="KEY_INFO" mapto="contextMenu" flags="m" />
-		<key id="KEY_MENU" mapto="contextMenu" flags="m" />
-		<key id="KEY_PROGRAM" mapto="timerAdd" flags="m" />
+		<key id="KEY_INFO" mapto="cancel" flags="m" />
+		<key id="KEY_HOME" mapto="cancel" flags="m" />
 	</map>
 	
 	<map context="EventViewEPGActions">
 		<key id="KEY_YELLOW" mapto="openSingleServiceEPG" flags="m" />
 		<key id="KEY_BLUE" mapto="openMultiServiceEPG" flags="m" />
-		<key id="KEY_EPG" mapto="openSingleServiceEPG" flags="m" />
 	</map>
 
 	<map context="OkCancelActions">
-		<key id="\x0a" mapto="ok" flags="m" />
-		<key id="\x1b" mapto="cancel" flags="m" />
-
-		<!-- use this on rcu, ok? -->
 		<key id="KEY_OK" mapto="ok" flags="m" />
 		<key id="KEY_EXIT" mapto="cancel" flags="m" />
-
 		<key id="KEY_ENTER" mapto="ok" flags="m" />
-		<key id="KEY_ESC" mapto="cancel" flags="m" />
+		<key id="KEY_HOME" mapto="cancel" flags="m" />
 	</map>
 	
 	<map context="DirectionActions">
@@ -564,7 +429,7 @@
 		<key id="KEY_OK" mapto="ok" flags="m" />
 		<key id="KEY_ENTER" mapto="ok" flags="m" />
 		<key id="KEY_RED" mapto="cancel" flags="m" />
-		<key id="KEY_EXIT" mapto="cancel" flags="m" />
+		<key id="KEY_HOME" mapto="cancel" flags="m" />
 		<key id="KEY_ESC" mapto="cancel" flags="m" />
 	</map>
 
@@ -589,13 +454,12 @@
 	</map>
 	<map context="StandbyActions">
 		<key id="KEY_POWER" mapto="power" flags="m" />
-		<key id="KEY_KP1" mapto="discrete_on" flags="m" />
 	</map>
 	
 	<map context="SleepTimerEditorActions">
 		<key id="KEY_OK" mapto="select" flags="m" />
 		<key id="KEY_ENTER" mapto="select" flags="m" />
-		<key id="KEY_EXIT" mapto="exit" flags="m" />
+		<key id="KEY_HOME" mapto="exit" flags="m" />
 		<key id="KEY_ESC" mapto="exit" flags="m" />
 		<key id="KEY_1" mapto="1" flags="m" />
 		<key id="KEY_2" mapto="2" flags="m" />
@@ -625,7 +489,7 @@
 		<key id="KEY_DOWN" mapto="down" flags="mr" />
 		<key id="KEY_LEFT" mapto="left" flags="mr" />
 		<key id="KEY_RIGHT" mapto="right" flags="mr" />
-		<key id="KEY_EXIT" mapto="cancel" flags="m" />
+		<key id="KEY_HOME" mapto="cancel" flags="m" />
 		<key id="KEY_ESC" mapto="cancel" flags="m" />
 		<key id="KEY_ENTER" mapto="ok" flags="m" />
 		<key id="KEY_OK" mapto="ok" flags="m" />
@@ -634,78 +498,18 @@
 	</map>
 	
 	<map context="MediaPlayerActions">
-		<device name="dreambox advanced remote control (native)">
-			<key id="KEY_RECORD" mapto="shift_record" flags="l" />
-			<key id="KEY_PREVIOUS" mapto="previous" flags="m" />
-			<key id="KEY_NEXT" mapto="next" flags="m" />
-		</device>
-		<device name="dreambox remote control (native)">
-			<key id="KEY_YELLOW" mapto="pause" flags="m" />
-			<key id="KEY_GREEN" mapto="play" flags="m" />
-			<key id="KEY_RADIO" mapto="shift_record" flags="l" />
-			<key id="KEY_PREVIOUS" mapto="previous" flags="m" />
-			<key id="KEY_NEXT" mapto="next" flags="m" />
-		</device>
-		<device name="dreambox ir keyboard">
-			<key id="KEY_RECORD" mapto="shift_record" flags="l" />
-			<key id="KEY_PREVIOUSSONG" mapto="previous" flags="m" />
-			<key id="KEY_NEXTSONG" mapto="next" flags="m" />
-		</device>
-		<key id="KEY_PLAYPAUSE" mapto="pause" flags="m" />
 		<key id="KEY_PAUSE" mapto="pause" flags="m" />
 		<key id="KEY_PLAY" mapto="play" flags="m" />
 		<key id="KEY_STOP" mapto="stop" flags="b" />
-		<key id="KEY_STOP" mapto="shift_stop" flags="l" />
-		<key id="KEY_BACK" mapto="stop" flags="m" />
-		<key id="KEY_TV" mapto="stop" flags="b" />
-		<key id="KEY_TV" mapto="shift_stop" flags="l" />
-
+		<key id="KEY_LEFT" mapto="previous" flags="m" />
+		<key id="KEY_RIGHT" mapto="next" flags="m" />
+		
 		<key id="KEY_MENU" mapto="menu" flags="m" />
-		<key id="KEY_SPACE" mapto="menu" flags="m" />
 
 		<key id="KEY_2" mapto="skipListbegin" flags="m" />
 		<key id="KEY_8" mapto="skipListend" flags="m" />
-		<key id="KEY_CHANNELUP" mapto="nextBouquet" flags="m" />
-		<key id="KEY_CHANNELDOWN" mapto="prevBouquet" flags="m" />
-		<key id="KEY_VIDEO" mapto="delete" flags="m" />
+		<key id="KEY_PAGEUP" mapto="nextBouquet" flags="m" />
+		<key id="KEY_PAGEDOWN" mapto="prevBouquet" flags="m" />
 		<key id="KEY_TEXT" mapto="subtitles" flags="m" />
-		<key id="KEY_FILE" mapto="nextBouquet" flags="m" />
-		<key id="KEY_LIST" mapto="prevBouquet" flags="m" />
-	</map>
-
-	<map context="DVDPlayerActions">
-		<key id="KEY_MENU" mapto="dvdMenu" flags="m" />
-		<key id="KEY_INFO" mapto="toggleInfo" flags="m" />
-		<key id="KEY_CHANNELUP" mapto="nextTitle" flags="m" />
-		<key id="KEY_CHANNELDOWN" mapto="prevTitle" flags="m" />
-		<device name="dreambox remote control (native)">
-			<key id="KEY_PREVIOUS" mapto="prevChapter" flags="m" />
-			<key id="KEY_NEXT" mapto="nextChapter" flags="m" />
-			<key id="KEY_TV" mapto="tv" flags="m" />
-			<key id="KEY_AUDIO" mapto="AudioSelection" flags="m" />
-			<key id="KEY_AUDIO" mapto="dvdAudioMenu" flags="l" />
-			<key id="KEY_RADIO" mapto="nextAudioTrack" flags="m" />
-			<key id="KEY_TEXT" mapto="nextSubtitleTrack" flags="m" />
-			<key id="KEY_VIDEO" mapto="nextAngle" flags="m" />
-		</device>
-		<device name="dreambox advanced remote control (native)">
-			<key id="KEY_PREVIOUS" mapto="prevChapter" flags="m" />
-			<key id="KEY_NEXT" mapto="nextChapter" flags="m" />
-			<key id="KEY_TV" mapto="tv" flags="m" />
-			<key id="KEY_STOP" mapto="tv" flags="m" />
-			<key id="KEY_RADIO" mapto="dvdAudioMenu" flags="l" />
-			<key id="KEY_RADIO" mapto="nextAudioTrack" flags="m" />
-			<key id="KEY_TEXT" mapto="nextSubtitleTrack" flags="m" />
-			<key id="KEY_VIDEO" mapto="nextAngle" flags="m" />
-		</device>
-		<!--device name="dreambox ir keyboard">
-			<key id="KEY_PAUSE" mapto="pause" flags="m" />
-			<key id="KEY_PLAY" mapto="play" flags="m" />
-			<key id="KEY_STOP" mapto="stop" flags="b" />
-			<key id="KEY_STOP" mapto="shift_stop" flags="l" />
-			<key id="KEY_RECORD" mapto="shift_record" flags="l" />
-			<key id="KEY_PREVIOUSSONG" mapto="previous" flags="m" />
-			<key id="KEY_NEXTSONG" mapto="next" flags="m" />
-		</device-->
 	</map>
 </keymap>
diff -Naur gui_orig/lib/base/etpm.cpp gui_new/lib/base/etpm.cpp
--- gui_orig/lib/base/etpm.cpp	2013-05-14 22:15:18.369079252 +0200
+++ gui_new/lib/base/etpm.cpp	2013-05-14 22:15:08.115955488 +0200
@@ -6,14 +6,17 @@
 #include <string.h>
 #include <sys/un.h>
 #include <unistd.h>
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 #include <openssl/bn.h>
 #include <openssl/sha.h>
+#endif
 #include <lib/base/eerror.h>
 
 #include "etpm.h"
 
 eTPM::eTPM()
 {
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 	struct sockaddr_un addr;
 	unsigned char buf[8];
 	unsigned int tag;
@@ -53,6 +56,7 @@
 
 	parse_data(val, len);
 	free(val);
+#endif
 }
 
 eTPM::~eTPM()
@@ -63,6 +67,7 @@
 
 bool eTPM::send_cmd(enum tpmd_cmd cmd, const void *data, size_t len)
 {
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 	unsigned char buf[len + 4];
 
 	buf[0] = (cmd >> 8) & 0xff;
@@ -77,11 +82,13 @@
 		return false;
 	}
 
+#endif
 	return true;
 }
 
 void* eTPM::recv_cmd(unsigned int *tag, size_t *len)
 {
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 	unsigned char buf[4];
 	void *val;
 
@@ -111,10 +118,14 @@
 	}
 
 	return val;
+#else
+	return NULL;
+#endif
 }
 
 void eTPM::parse_data(const unsigned char *data, size_t datalen)
 {
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 	unsigned int i;
 	unsigned int tag;
 	unsigned int len;
@@ -140,19 +151,23 @@
 			break;
 		}
 	}
+#endif
 }
 
 std::string eTPM::getCert(cert_type type)
 {
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 	if (type == TPMD_DT_LEVEL2_CERT && level2_cert_read)
 		return std::string((char*)level2_cert, 210);
 	else if (type == TPMD_DT_LEVEL3_CERT && level3_cert_read)
 		return std::string((char*)level3_cert, 210);
+#endif
 	return "";
 }
 
 std::string eTPM::challenge(std::string rnd)
 {
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 	if (rnd.length() == 8)
 	{
 		if (!send_cmd(TPMD_CMD_COMPUTE_SIGNATURE, rnd.c_str(), 8))
@@ -169,5 +184,6 @@
 		free(val);
 		return ret;
 	}
+#endif
 	return "";
 }
diff -Naur gui_orig/lib/base/filepush.cpp gui_new/lib/base/filepush.cpp
--- gui_orig/lib/base/filepush.cpp	2013-05-14 22:15:18.369079252 +0200
+++ gui_new/lib/base/filepush.cpp	2013-05-14 22:15:08.115955488 +0200
@@ -4,6 +4,15 @@
 #include <fcntl.h>
 #include <sys/ioctl.h>
 
+#if defined(__sh__) // this allows filesystem tasks to be prioritised
+#include <sys/vfs.h>
+#define USBDEVICE_SUPER_MAGIC 0x9fa2
+#define EXT2_SUPER_MAGIC      0xEF53
+#define EXT3_SUPER_MAGIC      0xEF53
+#define SMB_SUPER_MAGIC       0x517B
+#define NFS_SUPER_MAGIC       0x6969
+#define MSDOS_SUPER_MAGIC     0x4d44 /* MD */
+#endif
 //#define SHOW_WRITE_TIME
 
 eFilePushThread::eFilePushThread(int io_prio_class, int io_prio_level, int blocksize, size_t buffersize)
@@ -51,10 +60,30 @@
 	
 	hasStarted();
 
+#if defined(__sh__)
+// opens video device for the reverse playback workaround
+// Changes in this file are cause e2 doesnt tell the player to play reverse
+	int fd_video = open("/dev/dvb/adapter0/video0", O_RDONLY);
+// Fix to ensure that event evtEOF is called at end of playbackl part 1/3
+	bool already_empty = false;
+#endif
+
 	while (!m_stop)
 	{
 		if (m_sg && !current_span_remaining)
 		{
+#if defined (__sh__) // tells the player to play in reverse
+#define VIDEO_DISCONTINUITY                   _IO('o', 84)
+#define DVB_DISCONTINUITY_SKIP                0x01
+#define DVB_DISCONTINUITY_CONTINUOUS_REVERSE  0x02
+			if ((m_sg->getSkipMode() != 0))
+			{
+				// inform the player about the jump in the stream data
+				// this only works if the video device allows the discontinuity ioctl in read-only mode (patched)
+				int param = DVB_DISCONTINUITY_SKIP; // | DVB_DISCONTINUITY_CONTINUOUS_REVERSE;
+				int rc = ioctl(fd_video, VIDEO_DISCONTINUITY, (void*)param);
+			}
+#endif
 			m_sg->getNextSourceSpan(m_current_position, bytes_read, current_span_offset, current_span_remaining);
 			ASSERT(!(current_span_remaining % m_blocksize));
 			m_current_position = current_span_offset;
@@ -121,7 +150,19 @@
 				{
 					case 0:
 						eDebug("wait for driver eof timeout");
+#if defined(__sh__) // Fix to ensure that event evtEOF is called at end of playbackl part 2/3
+						if (already_empty)
+						{
+							break;
+						}
+						else
+						{
+							already_empty = true;
+							continue;
+						}
+#else
 						continue;
+#endif
 					case 1:
 						eDebug("wait for driver eof ok");
 						break;
@@ -183,12 +224,18 @@
 			}
 
 			eofcount = 0;
+#if defined(__sh__) // Fix to ensure that event evtEOF is called at end of playbackl part 3/3
+			already_empty = false;
+#endif
 			m_current_position += buf_end;
 			bytes_read += buf_end;
 			if (m_sg)
 				current_span_remaining -= buf_end;
 		}
 	}
+#if defined(__sh__) // closes video device for the reverse playback workaround
+	close(fd_video);
+#endif
 	sendEvent(evtStopped);
 	eDebug("FILEPUSH THREAD STOP");
 }
diff -Naur gui_orig/lib/base/filepush.h gui_new/lib/base/filepush.h
--- gui_orig/lib/base/filepush.h	2013-05-14 22:15:18.369079252 +0200
+++ gui_new/lib/base/filepush.h	2013-05-14 22:15:08.115955488 +0200
@@ -13,6 +13,10 @@
 public:
 	virtual void getNextSourceSpan(off_t current_offset, size_t bytes_read, off_t &start, size_t &size)=0;
 	virtual ~iFilePushScatterGather() {}
+#if defined(__sh__)
+	//Changes in this file are cause e2 doesnt tell the player to play reverse
+	virtual int getSkipMode() = 0;
+#endif
 };
 
 class eFilePushThread: public eThread, public Object
diff -Naur gui_orig/lib/base/ioprio.cpp gui_new/lib/base/ioprio.cpp
--- gui_orig/lib/base/ioprio.cpp	2013-05-14 22:15:18.369079252 +0200
+++ gui_new/lib/base/ioprio.cpp	2013-05-14 22:15:08.115955488 +0200
@@ -28,6 +28,9 @@
 #elif defined(__mips__)
 #define __NR_ioprio_set		4284
 #define __NR_ioprio_get		4285
+#elif defined(__sh__) // the correct values for our kernel
+#define __NR_ioprio_set		288
+#define __NR_ioprio_get		289
 #else
 #error "Unsupported arch"
 #endif
diff -Naur gui_orig/lib/base/object.h gui_new/lib/base/object.h
--- gui_orig/lib/base/object.h	2013-05-14 22:15:18.369079252 +0200
+++ gui_new/lib/base/object.h	2013-05-14 22:15:08.115955488 +0200
@@ -1,7 +1,9 @@
 #ifndef __base_object_h
 #define __base_object_h
 
+#if !defined(__sh__)
 #include <ext/atomicity.h>
+#endif
 
 #include <assert.h>
 #include <lib/base/smartptr.h>
@@ -34,23 +36,39 @@
 
 class oRefCount
 {
+#if defined(__sh__)
+	int ref;
+#else
 	mutable _Atomic_word ref;
+#endif
 public:
 	oRefCount(): ref(0) {}
 
 	int operator++()
 	{
+#if defined(__sh__)
+		return ++ref;
+#else
 		return __gnu_cxx::__exchange_and_add(&ref, 1) + 1;
+#endif
 	}
 
 	int operator--()
 	{
+#if defined(__sh__)
+		return --ref;
+#else
 		return __gnu_cxx::__exchange_and_add(&ref, -1) - 1;
+#endif
 	}
 
 	operator int() const
 	{
+#if defined(__sh__)
+		return ref;
+#else
 		return __gnu_cxx::__exchange_and_add(&ref, 0);
+#endif
 	}
 };
 
diff -Naur gui_orig/lib/driver/rc.cpp gui_new/lib/driver/rc.cpp
--- gui_orig/lib/driver/rc.cpp	2013-05-14 22:15:18.749120903 +0200
+++ gui_new/lib/driver/rc.cpp	2013-05-14 22:15:08.155959872 +0200
@@ -148,6 +148,9 @@
 
 bool eRCInputEventDriver::isKeyboard()
 {
+	if (getDeviceName().find("RC") != std::string::npos)
+		return false;
+
 	/* check whether the input device has KEY_A, in which case we assume it is a keyboard */
 	return hasCap(keyCaps, KEY_A);
 }
diff -Naur gui_orig/lib/dvb/decoder.cpp gui_new/lib/dvb/decoder.cpp
--- gui_orig/lib/dvb/decoder.cpp	2013-05-14 22:15:18.457088896 +0200
+++ gui_new/lib/dvb/decoder.cpp	2013-05-14 22:15:08.151959433 +0200
@@ -40,7 +40,11 @@
 	pes.input    = DMX_IN_FRONTEND;
 	pes.output   = DMX_OUT_DECODER;
 	pes.pes_type = m_dev ? DMX_PES_AUDIO1 : DMX_PES_AUDIO0; /* FIXME */
+#if defined(__sh__) // increases zapping speed
+	pes.flags    = DMX_IMMEDIATE_START;
+#else
 	pes.flags    = 0;
+#endif
 	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - audio - ", pid);
 	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 	{
@@ -48,6 +52,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#if not defined(__sh__) // already startet cause of DMX_IMMEDIATE_START
 	eDebugNoNewLine("DEMUX_START - audio - ");
 	if (::ioctl(m_fd_demux, DMX_START) < 0)
 	{
@@ -55,6 +60,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#endif
 	int bypass = 0;
 
 	switch (type)
@@ -90,7 +96,9 @@
 		eDebug("failed (%m)");
 	else
 		eDebug("ok");
+#if not defined(__sh__) // this is a hack which only matters for dm drivers
 	freeze();  // why freeze here?!? this is a problem when only a pid change is requested... because of the unfreeze logic in Decoder::setState
+#endif
 	eDebugNoNewLine("AUDIO_PLAY - ");
 	if (::ioctl(m_fd, AUDIO_PLAY) < 0)
 		eDebug("failed (%m)");
@@ -265,7 +273,11 @@
 	pes.input    = DMX_IN_FRONTEND;
 	pes.output   = DMX_OUT_DECODER;
 	pes.pes_type = m_dev ? DMX_PES_VIDEO1 : DMX_PES_VIDEO0; /* FIXME */
+#if defined(__sh__) // increases zapping speed
+	pes.flags    = DMX_IMMEDIATE_START;
+#else
 	pes.flags    = 0;
+#endif
 	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - video - ", pid);
 	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 	{
@@ -273,6 +285,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#if not defined(__sh__) // already startet cause of DMX_IMMEDIATE_START
 	eDebugNoNewLine("DEMUX_START - video - ");
 	if (::ioctl(m_fd_demux, DMX_START) < 0)
 	{
@@ -281,6 +294,7 @@
 	}
 	eDebug("ok");
 	freeze();  // why freeze here?!? this is a problem when only a pid change is requested... because of the unfreeze logic in Decoder::setState
+#endif
 	eDebugNoNewLine("VIDEO_PLAY - ");
 	if (::ioctl(m_fd, VIDEO_PLAY) < 0)
 		eDebug("failed (%m)");
@@ -522,7 +536,11 @@
 	pes.input    = DMX_IN_FRONTEND;
 	pes.output   = DMX_OUT_DECODER;
 	pes.pes_type = m_dev ? DMX_PES_PCR1 : DMX_PES_PCR0; /* FIXME */
+#if defined(__sh__) // increases zapping speed
+	pes.flags    = DMX_IMMEDIATE_START;
+#else
 	pes.flags    = 0;
+#endif
 	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - pcr - ", pid);
 	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 	{
@@ -530,6 +548,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#if not defined(__sh__) // already startet cause of DMX_IMMEDIATE_START
 	eDebugNoNewLine("DEMUX_START - pcr - ");
 	if (::ioctl(m_fd_demux, DMX_START) < 0)
 	{
@@ -537,6 +556,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#endif
 	return 0;
 }
 
@@ -577,7 +597,11 @@
 	pes.input    = DMX_IN_FRONTEND;
 	pes.output   = DMX_OUT_DECODER;
 	pes.pes_type = m_dev ? DMX_PES_TELETEXT1 : DMX_PES_TELETEXT0; // FIXME
+#if defined(__sh__) // increases zapping speed
+	pes.flags    = DMX_IMMEDIATE_START;
+#else
 	pes.flags    = 0;
+#endif
 
 	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - ttx - ", pid);
 	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
@@ -586,6 +610,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#if not defined(__sh__) // already startet cause of DMX_IMMEDIATE_START
 	eDebugNoNewLine("DEMUX_START - ttx - ");
 	if (::ioctl(m_fd_demux, DMX_START) < 0)
 	{
@@ -593,6 +618,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#endif
 	return 0;
 }
 
@@ -728,12 +754,28 @@
 		int *s = state_table[m_state];
 		if (changed & (changeState|changeVideo) && m_video)
 		{
+#if not defined(__sh__) // see comment below
 			m_video->setSlowMotion(s[1]);
 			m_video->setFastForward(s[2]);
+#endif 
 			if (s[0])
 				m_video->unfreeze();
 			else
 				m_video->freeze();
+#if defined(__sh__)
+// the VIDEO_CONTINUE would reset the FASTFORWARD  command so we
+// execute the FASTFORWARD after the VIDEO_CONTINUE
+			if (s[1])
+			{
+				m_video->setFastForward(s[2]);
+				m_video->setSlowMotion(s[1]);
+			}
+			else
+			{
+				m_video->setSlowMotion(s[1]);
+				m_video->setFastForward(s[2]);
+			}
+#endif
 		}
 		if (changed & (changeState|changeAudio) && m_audio)
 		{
@@ -1019,6 +1061,10 @@
 		{
 			struct stat s;
 			fstat(f, &s);
+#if defined(__sh__) // our driver has a different behaviour for iframes
+			if (m_video_clip_fd >= 0)
+				finishShowSinglePic();
+#endif
 			if (m_video_clip_fd == -1)
 				m_video_clip_fd = open("/dev/dvb/adapter0/video0", O_WRONLY);
 			if (m_video_clip_fd >= 0)
@@ -1034,8 +1080,10 @@
 				read(f, iframe, s.st_size);
 				if (ioctl(m_video_clip_fd, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_MEMORY) < 0)
 					eDebug("VIDEO_SELECT_SOURCE MEMORY failed (%m)");
+#if not defined(__sh__)
 				if (ioctl(m_video_clip_fd, VIDEO_SET_STREAMTYPE, streamtype) < 0)
 					eDebug("VIDEO_SET_STREAMTYPE failed(%m)");
+#endif 
 				if (ioctl(m_video_clip_fd, VIDEO_PLAY) < 0)
 					eDebug("VIDEO_PLAY failed (%m)");
 				if (ioctl(m_video_clip_fd, VIDEO_CONTINUE) < 0)
@@ -1052,7 +1100,9 @@
 				if (!seq_end_avail)
 					write(m_video_clip_fd, seq_end, sizeof(seq_end));
 				write(m_video_clip_fd, stuffing, 8192);
+#if not defined(__sh__)
 				m_showSinglePicTimer->start(150, true);
+#endif 
 			}
 			close(f);
 		}
diff -Naur gui_orig/lib/dvb/dvb.cpp gui_new/lib/dvb/dvb.cpp
--- gui_orig/lib/dvb/dvb.cpp	2013-05-14 22:15:18.745120464 +0200
+++ gui_new/lib/dvb/dvb.cpp	2013-05-14 22:15:08.155959872 +0200
@@ -113,6 +113,12 @@
 		m_boxtype = DM7020HD;
 	else if (!strncmp(tmp, "Gigablue\n", rd))
 		m_boxtype = GIGABLUE;	
+#if defined(__sh__)
+	else if (!strncmp(tmp, "spark\n", rd))
+		m_boxtype = SPARK;
+	else if (!strncmp(tmp, "spark7162\n", rd))
+		m_boxtype = SPARK7162;
+#else
 	else {
 		eDebug("boxtype detection via /proc/stb/info not possible... use fallback via demux count!\n");
 		if (m_demux.size() == 3)
@@ -122,7 +128,7 @@
 		else
 			m_boxtype = DM8000;
 	}
-
+#endif
 	eDebug("found %zd adapter, %zd frontends(%zd sim) and %zd demux, boxtype %d",
 		m_adapter.size(), m_frontend.size(), m_simulate_frontend.size(), m_demux.size(), m_boxtype);
 
@@ -948,6 +954,55 @@
 			}
 		}
 	}
+#if defined(__sh__) // we use our own algo for demux detection
+	else if (m_boxtype == SPARK || m_boxtype == SPARK7162)
+	{
+		int n=0;
+		for (; i != m_demux.end(); ++i, ++n)
+		{
+			if(fe)
+			{
+				if (!i->m_inuse)
+				{
+					if (!unused)
+					{
+						// take the first unused
+						//eDebug("\nallocate demux b = %d\n",n);
+						unused = i;
+					}
+				}
+				else if (i->m_adapter == fe->m_adapter && i->m_demux->getSource() == fe->m_frontend->getDVBID())
+				{
+					// take the demux allocated to the same
+					// frontend,  just create a new reference
+					demux = new eDVBAllocatedDemux(i);
+					//eDebug("\nallocate demux b = %d\n",n);
+					return 0;
+				}
+			}
+			else if(n == (m_demux.size() - 1))
+			{
+				// Always use the last demux for PVR
+				// it is assumed that the last demux is not
+				// attached to a frontend. That is, there
+				// should be one instance of dvr & demux
+				// devices more than of frontend devices.
+				// Otherwise, playback and timeshift might
+				// interfere recording.
+				if (i->m_inuse)
+				{
+					// just create a new reference
+					demux = new eDVBAllocatedDemux(i);
+					//eDebug("\nallocate demux c = %d\n",n);
+					return 0;
+				}
+				unused = i;
+				//eDebug("\nallocate demux d = %d\n", n);
+				break;
+			}
+		}
+	}
+#endif
 	else
 	{
 		iDVBAdapter *adapter = fe ? fe->m_adapter : m_adapter.begin(); /* look for a demux on the same adapter as the frontend, or the first adapter for dvr playback */
@@ -2132,6 +2187,12 @@
 			return -ENODEV;
 		}
 #else
+#if defined(__sh__) // our pvr device is called dvr
+		char dvrDev[128];
+		int dvrIndex = m_mgr->m_adapter.begin()->getNumDemux() - 1;
+		sprintf(dvrDev, "/dev/dvb/adapter0/dvr%d", dvrIndex);
+		m_pvr_fd_dst = open(dvrDev, O_WRONLY);
+#else
 		ePtr<eDVBAllocatedDemux> &demux = m_demux ? m_demux : m_decoder_demux;
 		if (demux)
 		{
@@ -2148,6 +2209,7 @@
 			return -ENODEV;
 		}
 #endif
+#endif
 	}
 
 	m_pvr_thread = new eDVBChannelFilePush(m_source->getPacketSize());
diff -Naur gui_orig/lib/dvb/dvb.h gui_new/lib/dvb/dvb.h
--- gui_orig/lib/dvb/dvb.h	2013-05-14 22:15:18.745120464 +0200
+++ gui_new/lib/dvb/dvb.h	2013-05-14 22:15:08.151959433 +0200
@@ -166,7 +166,11 @@
 	DECLARE_REF(eDVBResourceManager);
 	int avail, busy;
 
+#if not defined(__sh__)
 	enum { DM7025, DM800, DM500HD, DM800SE, DM8000, DM7020HD, GIGABLUE };
+#else
+	enum { DM7025, DM800, DM500HD, DM800SE, DM8000, DM7020HD, GIGABLUE, SPARK, SPARK7162};
+#endif
 
 	int m_boxtype;
 
@@ -278,6 +282,9 @@
 		/* cannot be used for PVR channels. */
 	RESULT setChannel(const eDVBChannelID &id, ePtr<iDVBFrontendParameters> &feparam);
 	eDVBChannelID getChannelID() { return m_channel_id; }
+#if defined(__sh__) //see filepush.h
+	int getSkipMode() { return m_skipmode_m; }
+#endif
 
 	RESULT connectStateChange(const Slot1<void,iDVBChannel*> &stateChange, ePtr<eConnection> &connection);
 	RESULT connectEvent(const Slot2<void,iDVBChannel*,int> &eventChange, ePtr<eConnection> &connection);
diff -Naur gui_orig/lib/dvb/epgcache.cpp gui_new/lib/dvb/epgcache.cpp
--- gui_orig/lib/dvb/epgcache.cpp	2013-05-14 22:15:18.745120464 +0200
+++ gui_new/lib/dvb/epgcache.cpp	2013-05-14 22:15:08.151959433 +0200
@@ -220,10 +220,22 @@
 	int tmp = ByteSize - 10;
 	memcpy(data, EITdata, 10);
 	unsigned int descriptors_length = 0;
+#ifndef __sh__
 	__u32 *p = (__u32*)(EITdata + 10);
+#else
+	// Dagobert: fix not aligned access
+	__u8 *p = (__u8*)(EITdata+10);
+#endif
 	while (tmp > 3)
 	{
+#ifndef __sh__
 		descriptorMap::iterator it = descriptors.find(*p++);
+#else
+		__u32 index = p[3] << 24 | p[2] << 16 | p[1] << 8 | p[0];
+		// eDebug("index %d %x, %x %x %x %x\n", index, index, p[0], p[1], p[2], p[3]);
+		descriptorMap::iterator it = descriptors.find(index);
+		p += 4;
+#endif
 		if (it != descriptors.end())
 		{
 			unsigned int b = it->second.second[1] + 2;
@@ -248,12 +260,23 @@
 	if ( ByteSize )
 	{
 		CacheSize -= ByteSize;
+#ifndef __sh__
 		__u32 *d = (__u32*)(EITdata+10);
+#else	// Dagobert: fix not aligned access
+		__u8 *d = (__u8*)(EITdata+10);
+#endif
 		ByteSize -= 10;
 		while(ByteSize>3)
 		{
+#ifndef __sh__
 			descriptorMap::iterator it =
 				descriptors.find(*d++);
+#else
+			__u32 index = d[3] << 24 | d[2] << 16 | d[1] << 8 | d[0];
+			// eDebug("index %d %x, %x %x %x %x\n", index, index, d[0], d[1], d[2], d[3]);
+			descriptorMap::iterator it = descriptors.find(index);
+			d += 4;
+#endif
 			if ( it != descriptors.end() )
 			{
 				descriptorPair &p = it->second;
@@ -1786,6 +1809,45 @@
 {
 	int map;
 	iDVBSectionReader *reader = NULL;
+#ifdef __sh__
+/* Dagobert: this is still very hacky, but currently I cant find
+ * the origin of the readData call. I think the caller is
+ * responsible for the unaligned data pointer in this call.
+ * So we malloc our own memory here which _should_ be aligned.
+ *
+ * TODO: We should search for the origin of this call. As I
+ * said before I need an UML Diagram or must try to import
+ * e2 and all libs into an IDE for better overview ;)
+ *
+ */
+	const __u8 *aligned_data;
+	bool isNotAligned = false;
+
+	if ((unsigned int) data % 4 != 0)
+		isNotAligned = true;
+
+	if (isNotAligned)
+	{
+		/* see HILO macro and eit.h */
+		int len = ((data[1] & 0x0F) << 8 | data[2]) -1;
+
+		/*eDebug("len %d %x, %x %x\n", len, len, data[1], data[2]);*/
+
+		if ( EIT_SIZE >= len )
+			return;
+
+		aligned_data = (const __u8 *) malloc(len);
+
+		if ((unsigned int)aligned_data % 4 != 0)
+		{
+			eDebug("eEPGCache::channel_data::readData: ERRORERRORERROR: unaligned data pointer %p\n", aligned_data);
+		}
+
+		/*eDebug("%p %p\n", aligned_data, data); */
+		memcpy((void *) aligned_data, (const __u8 *) data, len);
+		data = aligned_data;
+	}
+#endif
 	switch (source)
 	{
 		case NOWNEXT:
@@ -1890,6 +1952,10 @@
 			cache->sectionRead(data, source, this);
 		}
 	}
+#ifdef __sh__
+	if (isNotAligned)
+		free((void *)aligned_data);
+#endif
 }
 
 #if ENABLE_FREESAT
@@ -2973,11 +3039,20 @@
 						{
 							__u8 *data = evData->EITdata;
 							int tmp = evData->ByteSize-10;
+#ifndef __sh__
 							__u32 *p = (__u32*)(data+10);
+#else	// Dagobert: Alignment fix
+							__u8 *p = (__u8*)(data+10);
+#endif
 							// search short and extended event descriptors
 							while(tmp>3)
 							{
+#ifndef __sh__
 								__u32 crc = *p++;
+#else	// Dagobert: Alignment fix
+								__u32 crc = p[3] << 24 | p[2] << 16 | p[1] << 8 | p[0];
+								p += 4;
+#endif
 								descriptorMap::iterator it =
 									eventData::descriptors.find(crc);
 								if (it != eventData::descriptors.end())
@@ -3156,12 +3231,21 @@
 				}
 				__u8 *data = evit->second->EITdata;
 				int tmp = evit->second->ByteSize-10;
+#ifndef __sh__
 				__u32 *p = (__u32*)(data+10);
+#else	// Dagobert: Alignment fix
+				__u8 *p = (__u8*)(data+10);
+#endif
 				// check if any of our descriptor used by this event
 				int cnt=-1;
 				while(tmp>3)
 				{
+#ifndef __sh__
 					__u32 crc32 = *p++;
+#else	// Dagobert: Alignment fix
+					__u32 crc32 = p[3] << 24 | p[2] << 16 | p[1] << 8 | p[0];
+					p += 4;
+#endif
 					for ( int i=0; i <= descridx; ++i)
 					{
 						if (descr[i] == crc32)  // found...
diff -Naur gui_orig/lib/dvb/pmt.cpp gui_new/lib/dvb/pmt.cpp
--- gui_orig/lib/dvb/pmt.cpp	2013-05-14 22:15:18.457088896 +0200
+++ gui_new/lib/dvb/pmt.cpp	2013-05-14 22:15:08.151959433 +0200
@@ -1106,6 +1106,11 @@
 			eDVBCIInterfaces::getInstance()->addPMTHandler(this);
 	} else if (!simulate) // no simulation of playback services
 	{
+		if (m_service_type == streamclient)
+		{
+			eDebug("force setServiceID(1)");
+			m_reference.setServiceID(1);
+		}
 		if (!ref.getServiceID().get() /* incorrect sid in meta file or recordings.epl*/ )
 		{
 			eDVBTSTools tstools;
diff -Naur gui_orig/lib/dvb/volume.cpp gui_new/lib/dvb/volume.cpp
--- gui_orig/lib/dvb/volume.cpp	2013-05-14 22:15:18.725118269 +0200
+++ gui_new/lib/dvb/volume.cpp	2013-05-14 22:15:08.151959433 +0200
@@ -34,7 +34,9 @@
 	openMixer();
 #endif
 	volumeUnMute();
+#if not defined (__sh__) // dont reset volume on start
 	setVolume(100, 100);
+#endif
 }
 
 int eDVBVolumecontrol::openMixer()
diff -Naur gui_orig/lib/dvb_ci/dvbci_appmgr.cpp gui_new/lib/dvb_ci/dvbci_appmgr.cpp
--- gui_orig/lib/dvb_ci/dvbci_appmgr.cpp	2013-05-14 22:15:18.365078812 +0200
+++ gui_new/lib/dvb_ci/dvbci_appmgr.cpp	2013-05-14 22:15:08.115955488 +0200
@@ -94,6 +94,9 @@
 	eDebug("in appmanager -> startmmi()");
 	const unsigned char tag[3]={0x9F, 0x80, 0x22};  // Tenter_menu
 	sendAPDU(tag);
+#ifdef __sh__
+	slot->mmiOpened();
+#endif
 	return 0;
 }
 
diff -Naur gui_orig/lib/dvb_ci/dvbci.cpp gui_new/lib/dvb_ci/dvbci.cpp
--- gui_orig/lib/dvb_ci/dvbci.cpp	2013-05-14 22:15:18.365078812 +0200
+++ gui_new/lib/dvb_ci/dvbci.cpp	2013-05-14 22:15:08.115955488 +0200
@@ -18,6 +18,11 @@
 
 #include <dvbsi++/ca_program_map_section.h>
 
+#ifdef __sh__
+#include <linux/dvb/ca.h>
+//#define x_debug
+#endif
+
 //#define CIDEBUG 1
 
 #ifdef CIDEBUG
@@ -28,6 +33,229 @@
 
 eDVBCIInterfaces *eDVBCIInterfaces::instance = 0;
 
+#ifdef __sh__
+bool eDVBCISlot::checkQueueSize()
+{
+	return (sendqueue.size() > 0);
+}
+
+/* from dvb-apps */
+int asn_1_decode(uint16_t * length, unsigned char * asn_1_array,
+		 uint32_t asn_1_array_len)
+{
+	uint8_t length_field;
+
+	if (asn_1_array_len < 1)
+		return -1;
+	length_field = asn_1_array[0];
+
+	if (length_field < 0x80) {
+		// there is only one word
+		*length = length_field & 0x7f;
+		return 1;
+	} else if (length_field == 0x81) {
+		if (asn_1_array_len < 2)
+			return -1;
+
+		*length = asn_1_array[1];
+		return 2;
+	} else if (length_field == 0x82) {
+		if (asn_1_array_len < 3)
+			return -1;
+
+		*length = (asn_1_array[1] << 8) | asn_1_array[2];
+		return 3;
+	}
+
+	return -1;
+}
+
+//send some data on an fd, for a special slot and connection_id
+eData eDVBCISlot::sendData(unsigned char* data, int len)
+{
+#ifdef x_debug
+	printf("%s: %p, %d\n", __func__, data, len);
+#endif
+
+	unsigned char *d = (unsigned char*) malloc(len + 5);
+
+	/* should we send a data last ? */
+	if (data != NULL)
+	{
+		if ((data[2] >= T_SB) && (data[2] <= T_NEW_T_C))
+		{
+			memcpy(d, data, len);
+		}
+		else
+		{
+			//send data_last and data
+			memcpy(d + 5, data, len);
+			d[0] = getSlotID();
+			d[1] = connection_id;
+			d[2] = T_DATA_LAST;
+			d[3] = len + 1; 		/* len */
+			d[4] = connection_id; 	/* transport connection identifier*/
+			len += 5;
+		}
+	}
+	else
+	{
+		//send a data last only
+		d[0] = getSlotID();
+		d[1] = connection_id;
+		d[2] = T_DATA_LAST;
+		d[3] = len + 1; 		/* len */
+		d[4] = connection_id; 	/* transport connection identifier*/
+		len = 5;
+	}
+
+#ifdef x_debug
+	printf("write (%d): > ", getSlotID());
+	for (int i=0; i < len; i++)
+		printf("%02x ",d[i]);
+	printf("\n");
+#endif
+
+#ifdef direct_write
+	res = write(fd, d, len);
+
+	free(d);
+	if (res < 0 || res != len)
+	{
+		printf("error writing data to fd %d, slot %d: %m\n", fd, getSlotID());
+		return eDataError;
+	}
+#else
+	sendqueue.push( queueData(d, len) );
+#endif
+	return eDataReady;
+}
+
+//send a transport connection create request
+bool eDVBCISlot::sendCreateTC()
+{
+	//printf("%s:%s >\n", FILENAME, __FUNCTION__);
+	unsigned char* data = (unsigned char*) malloc(sizeof(char) * 5);
+	tx_time.tv_sec = 0;
+	data[0] = getSlotID();
+	data[1] = getSlotID() + 1; 	/* conid */
+	data[2] = T_CREATE_T_C;
+	data[3] = 1;
+	data[4] = getSlotID() + 1 	/*conid*/;
+	write(fd, data, 5);
+	//printf("%s:%s <\n", FILENAME, __FUNCTION__);
+	return true;
+}
+
+void eDVBCISlot::process_tpdu(unsigned char tpdu_tag, __u8* data, int asn_data_length, int con_id)
+{
+	switch (tpdu_tag)
+	{
+		case T_C_T_C_REPLY:
+			printf("Got CTC Replay (slot %d, con %d)\n", getSlotID(), connection_id);
+
+			tx_time.tv_sec = 0;
+
+			state = stateInserted;
+
+			//answer with data last (and if we have with data)
+			sendData(NULL, 0);
+
+			break;
+		case T_DELETE_T_C:
+//FIXME: close sessions etc; reset ?
+//we must answer here with t_c_replay
+			printf("Got \"Delete Transport Connection\" from module ->currently not handled!\n");
+			break;
+		case T_D_T_C_REPLY:
+			printf("Got \"Delete Transport Connection Replay\" from module!\n");
+			break;
+		case T_REQUEST_T_C:
+			printf("Got \"Request Transport Connection\" from Module ->currently not handled!\n");
+			break;
+		case T_DATA_MORE:
+		{
+			int new_data_length = receivedLen + asn_data_length;
+			printf("Got \"Data More\" from Module\n");
+			__u8 *new_data_buffer = (__u8*) realloc(receivedData, new_data_length);
+			receivedData = new_data_buffer;
+			memcpy(receivedData + receivedLen, data, asn_data_length);
+			receivedLen = new_data_length;
+			tx_time.tv_sec = 0;
+			break;
+		}
+		case T_DATA_LAST:
+#ifdef x_debug
+			printf("Got \"Data Last\" from Module\n");
+#endif
+			tx_time.tv_sec = 0;
+			/* single package */
+			if (receivedData == NULL)
+			{
+				printf("->single package\n");
+#ifdef x_debug
+				printf("calling receiveData with data (len %d)> ", asn_data_length);
+				for (int i = 0;i < asn_data_length; i++)
+					printf("%02x ", data[i]);
+				printf("\n");
+#endif
+				eDVBCISession::receiveData(this, data, asn_data_length);
+				eDVBCISession::pollAll();
+			}
+			else
+			{
+				/* chained package */
+				int new_data_length = receivedLen + asn_data_length;
+				printf("->chained data\n");
+				__u8 *new_data_buffer = (__u8*) realloc(receivedData, new_data_length);
+				receivedData = new_data_buffer;
+				memcpy(receivedData + receivedLen, data, asn_data_length);
+				receivedLen = new_data_length;
+#ifdef x_debug
+				printf("calling receiveData with data (len %d)> ", asn_data_length);
+				for (int i = 0;i < receivedLen; i++)
+					printf("%02x ", receivedData[i]);
+				printf("\n");
+#endif
+				eDVBCISession::receiveData(this, receivedData, receivedLen);
+				eDVBCISession::pollAll();
+//fixme: must also be moved in e2 behind the data processing ;)
+				free(receivedData);
+				receivedData = NULL;
+				receivedLen = 0;
+			}
+			break;
+		case T_SB:
+		{
+#ifdef x_debug
+			printf("Got \"SB\" from Module\n");
+#endif
+			if (data[0] & 0x80)
+			{
+				printf("->data ready (%d)\n", getSlotID());
+				// send the RCV and ask for the data
+				unsigned char send_data[5];
+				send_data[0] = getSlotID();
+				send_data[1] = connection_id;
+				send_data[2] = T_RCV;
+				send_data[3] = 1;
+				send_data[4] = connection_id;
+				write(fd, send_data, 5);
+				gettimeofday(&tx_time, 0);
+			}
+			else
+			{
+				tx_time.tv_sec = 0;
+			}
+			break;
+		}
+		default:
+			printf("unhandled tpdu_tag 0x%0x\n", tpdu_tag);
+	}
+}
+
+#endif
+
 eDVBCIInterfaces::eDVBCIInterfaces()
 {
 	int num_ci = 0;
@@ -39,7 +267,11 @@
 	while (1)
 	{
 		char filename[128];
+#ifdef __sh__
+		sprintf(filename, "/dev/dvb/adapter0/ci%d", num_ci);
+#else
 		sprintf(filename, "/dev/ci%d", num_ci);
+#endif
 
 		if (::access(filename, R_OK) < 0) break;
 
@@ -955,8 +1187,13 @@
 	{
 		unsigned char *d = new unsigned char[len];
 		memcpy(d, data, len);
+#ifdef __sh__
+		sendData(d, len);
+		notifier->setRequested(eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
+#else
 		sendqueue.push( queueData(d, len) );
 		notifier->setRequested(eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
+#endif
 	}
 
 	return res;
@@ -965,6 +1202,7 @@
 void eDVBCISlot::data(int what)
 {
 	eDebugCI("CISlot %d what %d\n", getSlotID(), what);
+#ifndef __sh__
 	if(what == eSocketNotifier::Priority) {
 		if(state != stateRemoved) {
 			state = stateRemoved;
@@ -1020,6 +1258,166 @@
 		else
 			notifier->setRequested(eSocketNotifier::Read|eSocketNotifier::Priority);
 	}
+#else
+	unsigned char data[1024];
+	int len = 1024;
+	unsigned char* d;
+	eData status;
+	ca_slot_info_t info;
+
+	if (what & eSocketNotifier::Read)
+	{
+		eDebugCI("eSocketNotifier::Read\n");
+		status = eDataReady;
+		len = ::read(fd, data, len);
+	}
+	else if (what & eSocketNotifier::Write)
+	{
+		eDebugCI("eSocketNotifier::Write\n");
+		status = eDataWrite;
+	}
+	else if (what & eSocketNotifier::Priority)
+	{
+		eDebugCI("eSocketNotifier::Priority\n");
+		status = eDataStatusChanged;
+	}
+
+	switch (getState())
+	{
+		case stateInvalid:
+		{
+			if (status == eDataStatusChanged)
+			{
+				info.num = getSlotID();
+
+				if (ioctl(fd, CA_GET_SLOT_INFO, &info) < 0)
+					printf("IOCTL CA_GET_SLOT_INFO failed for slot %d\n", getSlotID());
+
+				if (info.flags & CA_CI_MODULE_READY)
+				{
+					printf("1. cam status changed ->cam now present\n");
+					state = stateInserted;
+					mmi_active = false;
+					tx_time.tv_sec = 0;
+					application_manager = 0;
+					ca_manager = 0;
+					sendCreateTC();
+					eDVBCI_UI::getInstance()->setState(getSlotID(),1);
+				}
+			}
+			else
+			{
+				usleep(100000);
+			}
+		}
+		break;
+		case stateInserted:
+		{
+			if (status == eDataReady)
+			{
+				eDebugCI("received data - len %d\n", len);
+				//int s_id = data[0];
+				//int c_id = data[1];
+				//printf("%d: s_id = %d, c_id = %d\n", slot->slot, s_id, c_id);
+				d = data;
+				/* taken from the dvb-apps */
+				int data_length = len - 2;
+				d += 2; /* remove leading slot and connection id */
+				while (data_length > 0)
+				{
+					unsigned char tpdu_tag = d[0];
+					unsigned short asn_data_length;
+					int length_field_len;
+					if ((length_field_len = asn_1_decode(&asn_data_length, d + 1, data_length - 1)) < 0)
+					{
+						printf("Received data with invalid asn from module on slot %02x\n", getSlotID());
+						break;
+					}
+
+					if ((asn_data_length < 1) || (asn_data_length > (data_length - (1 + length_field_len))))
+					{
+						printf("Received data with invalid length from module on slot %02x\n", getSlotID());
+						break;
+					}
+					connection_id = d[1 + length_field_len];
+					//printf("Setting connection_id from received data to %d\n", slot->connection_id);
+					d += 1 + length_field_len + 1;
+					data_length -= (1 + length_field_len + 1);
+					asn_data_length--;
+					process_tpdu(tpdu_tag, d, asn_data_length, connection_id);
+					// skip over the consumed data
+					d += asn_data_length;
+					data_length -= asn_data_length;
+				} // while (data_length)
+			} /* data ready */
+			else if (status == eDataWrite)
+			{
+				if (!sendqueue.empty() && (tx_time.tv_sec == 0)) 
+				{
+					const queueData &qe = sendqueue.top();
+					int res = write(fd, qe.data, qe.len);
+					if (res >= 0 && (unsigned int)res == qe.len)
+					{
+						delete [] qe.data;
+						sendqueue.pop();
+						gettimeofday(&tx_time, 0);
+					}
+					else
+					{
+						printf("r = %d, %m\n", res);
+					}
+				}
+				/* the spec say's that we _must_ poll the connection
+				 * if the transport connection is in active state
+				 */
+				if ((tx_time.tv_sec == 0) && (!checkQueueSize()) && (time_after(last_poll_time, 1000)))
+				{
+					sendData(NULL, 0);
+					clock_gettime(CLOCK_MONOTONIC, &last_poll_time);
+				}
+			}
+			else if (status == eDataStatusChanged)
+			{
+				info.num = getSlotID();
+				if (ioctl(fd, CA_GET_SLOT_INFO, &info) < 0)
+					printf("IOCTL CA_GET_SLOT_INFO failed for slot %d\n", getSlotID());
+
+				if (info.flags & CA_CI_MODULE_READY)
+				{
+					printf("2. cam status changed ->cam now present\n");
+					mmi_active = false;
+					state = stateInvalid;
+					application_manager = 0;
+					ca_manager = 0;
+					tx_time.tv_sec = 0;
+					eDVBCI_UI::getInstance()->setState(getSlotID(),1); 
+				}
+				else if (!(info.flags & CA_CI_MODULE_READY))
+				{
+					printf("cam status changed ->cam now _not_ present\n");
+					eDVBCISession::deleteSessions(this);
+					mmi_active = false;
+					state = stateInvalid;
+					application_manager = 0;
+					ca_manager = 0;
+					tx_time.tv_sec = 0;
+					eDVBCIInterfaces::getInstance()->ciRemoved(this);
+					eDVBCI_UI::getInstance()->setState(getSlotID(),0);
+					while (sendqueue.size())
+					{
+						delete [] sendqueue.top().data;
+						sendqueue.pop();
+					}
+				}
+			}
+		}
+		break;
+		default:
+			printf("unknown state %d\n", state);
+		break;
+	}
+	notifier->setRequested(eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
+#endif
 }
 
 DEFINE_REF(eDVBCISlot);
@@ -1038,7 +1436,11 @@
 	
 	slotid = nr;
 
+#ifdef __sh__
+	sprintf(filename, "/dev/dvb/adapter0/ci%d", nr);
+#else
 	sprintf(filename, "/dev/ci%d", nr);
+#endif
 
 //	possible_caids.insert(0x1702);
 //	possible_providers.insert(providerPair("PREMIERE", 0xC00000));
@@ -1049,10 +1451,24 @@
 	eDebugCI("CI Slot %d has fd %d", getSlotID(), fd);
 	state = stateInvalid;
 
+#ifdef __sh__
+	receivedLen = 0;
+	receivedData = NULL;
+#endif
 	if (fd >= 0)
 	{
+#ifdef __sh__
+		connection_id = slotid + 1;
+		tx_time.tv_sec = 0;
+		tx_time.tv_usec = 0;
+		last_poll_time.tv_sec = 0;
+		last_poll_time.tv_nsec = 0;
+#endif
 		notifier = eSocketNotifier::create(context, fd, eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
 		CONNECT(notifier->activated, eDVBCISlot::data);
+#ifdef __sh__
+		reset();
+#endif
 	} else
 	{
 		perror(filename);
@@ -1088,6 +1504,13 @@
 {
 	eDebug("CI Slot %d: reset requested", getSlotID());
 
+#ifdef __sh__
+	state = stateInvalid;
+	mmi_active = false;
+	eDVBCI_UI::getInstance()->setAppName(getSlotID(), "");
+	eDVBCISession::deleteSessions(this);
+	eDVBCIInterfaces::getInstance()->ciRemoved(this);
+#else
 	if (state == stateInvalid)
 	{
 		unsigned char buf[256];
@@ -1095,6 +1518,7 @@
 		while(::read(fd, buf, 256)>0);
 		state = stateResetted;
 	}
+#endif
 
 	while(sendqueue.size())
 	{
@@ -1102,7 +1526,12 @@
 		sendqueue.pop();
 	}
 
+#ifdef __sh__
+	if (ioctl(fd, CA_RESET, getSlotID()) < 0)
+		eDebug("IOCTL CA_RESET failed for slot %d\n", slotid);
+#else
 	ioctl(fd, 0);
+#endif
 
 	return 0;
 }
diff -Naur gui_orig/lib/dvb_ci/dvbci.h gui_new/lib/dvb_ci/dvbci.h
--- gui_orig/lib/dvb_ci/dvbci.h	2013-05-14 22:15:18.365078812 +0200
+++ gui_new/lib/dvb_ci/dvbci.h	2013-05-14 22:15:08.115955488 +0200
@@ -5,6 +5,9 @@
 
 #include <lib/base/ebase.h>
 #include <lib/service/iservice.h>
+#ifdef __sh__
+#include <lib/base/thread.h>
+#endif
 #include <lib/python/python.h>
 #include <set>
 #include <queue>
@@ -43,6 +46,42 @@
 typedef std::set<uint16_t> caidSet;
 typedef std::set<eServiceReference> serviceSet;
 
+#ifdef __sh__
+/* ********************************** */
+/* constants taken from dvb-apps 
+ */
+#define T_SB                0x80	// sb                           primitive   h<--m
+#define T_RCV               0x81	// receive                      primitive   h-->m
+#define T_CREATE_T_C        0x82	// create transport connection  primitive   h-->m
+#define T_C_T_C_REPLY       0x83	// ctc reply                    primitive   h<--m
+#define T_DELETE_T_C        0x84	// delete tc                    primitive   h<->m
+#define T_D_T_C_REPLY       0x85	// dtc reply                    primitive   h<->m
+#define T_REQUEST_T_C       0x86	// request transport connection primitive   h<--m
+#define T_NEW_T_C           0x87	// new tc / reply to t_request  primitive   h-->m
+#define T_T_C_ERROR         0x77	// error creating tc            primitive   h-->m
+#define T_DATA_LAST         0xA0	// convey data from higher      constructed h<->m
+				 // layers
+#define T_DATA_MORE         0xA1	// convey data from higher      constructed h<->m
+				 // layers
+
+typedef enum {eDataTimeout, eDataError, eDataReady, eDataWrite, eDataStatusChanged} eData;
+
+static inline int time_after(struct timespec oldtime, uint32_t delta_ms)
+{
+	// calculate the oldtime + add on the delta
+	uint64_t oldtime_ms = (oldtime.tv_sec * 1000) + (oldtime.tv_nsec / 1000000);
+	oldtime_ms += delta_ms;
+
+	// calculate the nowtime
+	struct timespec nowtime;
+	clock_gettime(CLOCK_MONOTONIC, &nowtime);
+	uint64_t nowtime_ms = (nowtime.tv_sec * 1000) + (nowtime.tv_nsec / 1000000);
+
+	// check
+	return nowtime_ms > oldtime_ms;
+}
+#endif
+
 class eDVBCISlot: public iObject, public Object
 {
 	friend class eDVBCIInterfaces;
@@ -66,6 +105,13 @@
 	bool user_mapped;
 	void data(int);
 	bool plugged;
+#ifdef __sh__
+	//dagobert
+	char connection_id;
+	bool mmi_active;
+	int receivedLen;
+	unsigned char* receivedData;
+#endif
 public:
 	enum {stateRemoved, stateInserted, stateInvalid, stateResetted};
 	eDVBCISlot(eMainloop *context, int nr);
@@ -95,6 +141,17 @@
 	int getNumOfServices() { return running_services.size(); }
 	int setSource(data_source source);
 	int setClockRate(int);
+#ifdef __sh__
+	bool checkQueueSize();
+	void thread();
+	void mmiOpened() { mmi_active = true; };
+	void mmiClosed() { mmi_active = false; };
+	void process_tpdu(unsigned char tpdu_tag, __u8* data, int asn_data_length, int con_id);
+	bool sendCreateTC();
+	eData sendData(unsigned char* data, int len);
+	struct timeval tx_time;
+	struct timespec last_poll_time;
+#endif
 };
 
 struct CIPmtHandler
diff -Naur gui_orig/lib/dvb_ci/dvbci_mmi.cpp gui_new/lib/dvb_ci/dvbci_mmi.cpp
--- gui_orig/lib/dvb_ci/dvbci_mmi.cpp	2013-05-14 22:15:18.365078812 +0200
+++ gui_new/lib/dvb_ci/dvbci_mmi.cpp	2013-05-14 22:15:08.115955488 +0200
@@ -25,6 +25,9 @@
 
 eDVBCIMMISession::~eDVBCIMMISession()
 {
+#ifdef __sh__
+	slot->mmiClosed();
+#endif
 	slot->setMMIManager(NULL);
 	eDVBCI_UI::getInstance()->mmiSessionDestroyed(slot->getSlotID());
 }
diff -Naur gui_orig/lib/dvb_ci/dvbci_resmgr.cpp gui_new/lib/dvb_ci/dvbci_resmgr.cpp
--- gui_orig/lib/dvb_ci/dvbci_resmgr.cpp	2013-05-14 22:15:18.369079252 +0200
+++ gui_new/lib/dvb_ci/dvbci_resmgr.cpp	2013-05-14 22:15:08.115955488 +0200
@@ -5,7 +5,12 @@
 
 int eDVBCIResourceManagerSession::receivedAPDU(const unsigned char *tag,const void *data, int len)
 {
+#ifdef __sh__
+	eDebug("eDVBCIResourceManagerSession::%s >", __func__);
+	eDebugNoNewLine("SESSION(%d) %02x %02x %02x (len = %d): ", session_nb, tag[0], tag[1], tag[2], len);
+#else
 	eDebugNoNewLine("SESSION(%d) %02x %02x %02x: ", session_nb, tag[0], tag[1], tag[2]);
+#endif
 	for (int i=0; i<len; i++)
 		eDebugNoNewLine("%02x ", ((const unsigned char*)data)[i]);
 	eDebug("");
diff -Naur gui_orig/lib/dvb_ci/dvbci_session.cpp gui_new/lib/dvb_ci/dvbci_session.cpp
--- gui_orig/lib/dvb_ci/dvbci_session.cpp	2013-05-14 22:15:18.365078812 +0200
+++ gui_new/lib/dvb_ci/dvbci_session.cpp	2013-05-14 22:15:08.115955488 +0200
@@ -257,6 +257,12 @@
 		if ((!session_nb) || (session_nb >= SLMS))
 		{
 			eDebug("PROTOCOL: illegal session number %x", session_nb);
+#ifdef __sh__
+			//Dagobert during start-up we seems to have some problems
+			//on some modules which "looses" the connection. So reset it
+			deleteSessions(slot);
+			slot->reset();
+#endif
 			return;
 		}
 		
diff -Naur gui_orig/lib/gdi/accel.cpp gui_new/lib/gdi/accel.cpp
--- gui_orig/lib/gdi/accel.cpp	2013-05-14 22:15:18.365078812 +0200
+++ gui_new/lib/gdi/accel.cpp	2013-05-14 22:15:08.115955488 +0200
@@ -9,8 +9,25 @@
 #include <lib/gdi/gpixmap.h>
 
 gAccel *gAccel::instance;
+#if not defined(__sh__)
 #define BCM_ACCEL
+#else
+#define STMFB_ACCEL
+#endif
 
+#ifdef STMFB_ACCEL
+extern int stmfb_accel_init(void);
+extern void stmfb_accel_close(void);
+extern void stmfb_accel_blit(
+		int src_addr, int src_width, int src_height, int src_stride, int src_format,
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int src_x, int src_y, int width, int height,
+		int dst_x, int dst_y, int dwidth, int dheight);
+extern void stmfb_accel_fill(
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int x, int y, int width, int height,
+		unsigned long color);
+#endif
 #ifdef ATI_ACCEL
 extern int ati_accel_init(void);
 extern void ati_accel_close(void);
@@ -48,6 +65,9 @@
 	m_accel_allocation = 0;
 	instance = this;
 
+#ifdef STMFB_ACCEL
+	stmfb_accel_init();
+#endif
 #ifdef ATI_ACCEL	
 	ati_accel_init();
 #endif
@@ -58,6 +78,9 @@
 
 gAccel::~gAccel()
 {
+#ifdef STMFB_ACCEL
+	stmfb_accel_close();
+#endif
 #ifdef ATI_ACCEL
 	ati_accel_close();
 #endif
@@ -103,6 +126,77 @@
 
 int gAccel::blit(gSurface *dst, const gSurface *src, const eRect &p, const eRect &area, int flags)
 {
+#ifdef STMFB_ACCEL
+	//eDebug( "src: %4d %4d %4d %4d\tdst: %4d %4d %4d %4d\n"
+	//		"area: %4d %4d %4d %4d\tp: %4d %4d %4d %4d\n",
+	//		src->data_phys, src->x, src->y, src->stride,
+	//		dst->data_phys, dst->x, dst->y, dst->stride, 
+	//		area.left(), area.top(), area.width(), area.height(),
+	//		p.x(), p.y(), p.width(), p.height());
+
+	int src_format = 0;
+	void *data = 0;
+	int data_phys = 0;
+
+	if (src->bpp == 32)
+		src_format = 0;
+	else if ((src->bpp == 8) && (dst->bpp == 32))
+	{
+		src_format = 1;
+		if (accelAlloc(data, data_phys, area.height() * area.width() * 4))
+			return -1;
+
+		__u8 *srcptr=(__u8*)src->data;
+		__u8 *dstptr=(__u8*)data;
+		__u32 pal[256];
+
+		for (int i=0; i<256; ++i)
+		{
+			if (src->clut.data && (i<src->clut.colors))
+				pal[i]=(src->clut.data[i].a<<24)|(src->clut.data[i].r<<16)|(src->clut.data[i].g<<8)|(src->clut.data[i].b);
+			else
+				pal[i]=0x010101*i;
+			if ((pal[i]&0xFF000000) >= 0xE0000000)
+				pal[i] = 0xFF000000;
+			pal[i]^=0xFF000000;
+		}
+		srcptr+=area.left()*src->bypp+area.top()*src->stride;
+
+		for (int y=0; y<area.height(); y++)
+		{
+			int width=area.width();
+			unsigned char *psrc=(unsigned char*)srcptr;
+			__u32 *pdst=(__u32*)dstptr;
+
+			while (width--)
+				*pdst++=pal[*psrc++];
+
+			srcptr+=src->stride;
+			dstptr+=area.width() * 4;
+		}
+	} else {
+		if (data_phys)
+			accelFree(data_phys);
+		return -1;
+	}
+
+	if (data_phys)
+	{
+		stmfb_accel_blit(
+			data_phys, 0, 0, area.width() * 4, src_format,
+			dst->data_phys, dst->x, dst->y, dst->stride,
+			0, 0, area.width(), area.height(),
+			p.x(), p.y(), p.width(), p.height());
+		accelFree(data_phys);
+	} else {
+		stmfb_accel_blit(
+			src->data_phys, src->x, src->y, src->stride, src_format,
+			dst->data_phys, dst->x, dst->y, dst->stride,
+			area.left(), area.top(), area.width(), area.height(),
+			p.x(), p.y(), p.width(), p.height());
+	}
+	return 0;
+#endif
 #ifdef ATI_ACCEL
 	ati_accel_blit(
 		src->data_phys, src->x, src->y, src->stride,
diff -Naur gui_orig/lib/gdi/fb.cpp gui_new/lib/gdi/fb.cpp
--- gui_orig/lib/gdi/fb.cpp	2013-05-14 22:15:18.365078812 +0200
+++ gui_new/lib/gdi/fb.cpp	2013-05-14 22:15:08.115955488 +0200
@@ -8,6 +8,9 @@
 #include <linux/kd.h>
 
 #include <lib/gdi/fb.h>
+#ifdef __sh__
+#include <linux/stmfb.h>
+#endif
 
 #ifndef FBIO_WAITFORVSYNC
 #define FBIO_WAITFORVSYNC _IOW('F', 0x20, __u32)
@@ -47,11 +50,13 @@
 	}
 
 
+#if not defined(__sh__)
 	if (ioctl(fbFd, FBIOGET_VSCREENINFO, &screeninfo)<0)
 	{
 		perror("FBIOGET_VSCREENINFO");
 		goto nolfb;
 	}
+#endif
 
 	fb_fix_screeninfo fix;
 	if (ioctl(fbFd, FBIOGET_FSCREENINFO, &fix)<0)
@@ -62,8 +67,17 @@
 
 	available=fix.smem_len;
 	m_phys_mem = fix.smem_start;
+#if defined(__sh__)
+	eDebug("%dk total video mem", available/1024);
+	// The first 1920x1080x4 bytes are reserved
+	// After that we can take 1280x720x4 bytes for our virtual framebuffer
+	available -= 1920*1080*4;
+	eDebug("%dk usable video mem", available/1024);
+	lfb=(unsigned char*)mmap(0, available, PROT_WRITE|PROT_READ, MAP_SHARED, fbFd, 1920*1080*4);
+#else
 	eDebug("%dk video mem", available/1024);
 	lfb=(unsigned char*)mmap(0, available, PROT_WRITE|PROT_READ, MAP_SHARED, fbFd, 0);
+#endif
 	if (!lfb)
 	{
 		perror("mmap");
@@ -86,6 +100,7 @@
 
 int fbClass::showConsole(int state)
 {
+#if not defined(__sh__) 
 	int fd=open("/dev/tty0", O_RDWR);
 	if(fd>=0)
 	{
@@ -95,11 +110,19 @@
 		}
 		close(fd);
 	}
+#endif
 	return 0;
 }
 
 int fbClass::SetMode(int nxRes, int nyRes, int nbpp)
 {
+#if defined(__sh__)
+	xRes=nxRes;
+	yRes=nyRes;
+	bpp=32;
+	m_number_of_pages = 1;
+	topDiff=bottomDiff=leftDiff=rightDiff = 0;
+#else
 	screeninfo.xres_virtual=screeninfo.xres=nxRes;
 	screeninfo.yres_virtual=(screeninfo.yres=nyRes)*2;
 	screeninfo.height=0;
@@ -132,6 +155,7 @@
 		break;
 	}
 
+
 	if (ioctl(fbFd, FBIOPUT_VSCREENINFO, &screeninfo)<0)
 	{
 		// try single buffering
@@ -146,11 +170,18 @@
 		eDebug(" - double buffering not available.");
 	} else
 		eDebug(" - double buffering available!");
+
 	
 	m_number_of_pages = screeninfo.yres_virtual / nyRes;
 	
+#endif
 	ioctl(fbFd, FBIOGET_VSCREENINFO, &screeninfo);
 	
+#if defined(__sh__)
+	xResSc=screeninfo.xres;
+	yResSc=screeninfo.yres;
+	stride=xRes*4;
+#else
 	if ((screeninfo.xres!=nxRes) && (screeninfo.yres!=nyRes) && (screeninfo.bits_per_pixel!=nbpp))
 	{
 		eDebug("SetMode failed: wanted: %dx%dx%d, got %dx%dx%d",
@@ -168,15 +199,22 @@
 	}
 	stride=fix.line_length;
 	memset(lfb, 0, stride*yRes);
+#endif
 	blit();
 	return 0;
 }
 
 void fbClass::getMode(int &xres, int &yres, int &bpp)
 {
+#if defined(__sh__)
+	xres = xRes;
+	yres = yRes;
+	bpp = 32;
+#else
 	xres = screeninfo.xres;
 	yres = screeninfo.yres;
 	bpp = screeninfo.bits_per_pixel;
+#endif
 }
 
 int fbClass::setOffset(int off)
@@ -194,10 +232,93 @@
 
 void fbClass::blit()
 {
+#if defined(__sh__)
+	int modefd=open("/proc/stb/video/3d_mode", O_RDWR);
+	char buf[16] = "off";
+	if (modefd > 0)
+	{
+		read(modefd, buf, 15);
+		buf[15]='\0';
+		close(modefd);
+	}
+
+	STMFBIO_BLT_DATA    bltData;
+	memset(&bltData, 0, sizeof(STMFBIO_BLT_DATA));
+	bltData.operation  = BLT_OP_COPY;
+	bltData.srcOffset  = 1920*1080*4;
+	bltData.srcPitch   = xRes * 4;
+	bltData.dstOffset  = 0;
+	bltData.dstPitch   = xResSc*4;
+	bltData.src_top    = 0;
+	bltData.src_left   = 0;
+	bltData.src_right  = xRes;
+	bltData.src_bottom = yRes;
+	bltData.srcFormat  = SURF_BGRA8888;
+	bltData.dstFormat  = SURF_BGRA8888;
+	bltData.srcMemBase = STMFBGP_FRAMEBUFFER;
+	bltData.dstMemBase = STMFBGP_FRAMEBUFFER;
+
+	if (strncmp(buf,"sbs",3)==0)
+	{
+		bltData.dst_top    = 0 + topDiff;
+		bltData.dst_left   = 0 + leftDiff/2;
+		bltData.dst_right  = xResSc/2 + rightDiff/2;
+		bltData.dst_bottom = yResSc + bottomDiff;
+		if (ioctl(fbFd, STMFBIO_BLT, &bltData ) < 0)
+		{
+			perror("STMFBIO_BLT");
+		}
+		bltData.dst_top    = 0 + topDiff;
+		bltData.dst_left   = xResSc/2 + leftDiff/2;
+		bltData.dst_right  = xResSc + rightDiff/2;
+		bltData.dst_bottom = yResSc + bottomDiff;
+		if (ioctl(fbFd, STMFBIO_BLT, &bltData ) < 0)
+		{
+			perror("STMFBIO_BLT");
+		}
+	}
+	else if (strncmp(buf,"tab",3)==0)
+	{
+		bltData.dst_top    = 0 + topDiff/2;
+		bltData.dst_left   = 0 + leftDiff;
+		bltData.dst_right  = xResSc + rightDiff;
+		bltData.dst_bottom = yResSc/2 + bottomDiff/2;
+		if (ioctl(fbFd, STMFBIO_BLT, &bltData ) < 0)
+		{
+			perror("STMFBIO_BLT");
+		}
+		bltData.dst_top    = yResSc/2 + topDiff/2;
+		bltData.dst_left   = 0 + leftDiff;
+		bltData.dst_right  = xResSc + rightDiff;
+		bltData.dst_bottom = yResSc + bottomDiff/2;
+		if (ioctl(fbFd, STMFBIO_BLT, &bltData ) < 0)
+		{
+			perror("STMFBIO_BLT");
+		}
+	}
+	else
+	{
+		bltData.dst_top    = 0 + topDiff;
+		bltData.dst_left   = 0 + leftDiff;
+		bltData.dst_right  = xResSc + rightDiff;
+		bltData.dst_bottom = yResSc + bottomDiff;
+		if (ioctl(fbFd, STMFBIO_BLT, &bltData ) < 0)
+		{
+			perror("STMFBIO_BLT");
+		}
+	
+	}
+
+	if (ioctl(fbFd, STMFBIO_SYNC_BLITTER) < 0)
+	{
+		perror("STMFBIO_SYNC_BLITTER");
+	}
+#else
 	if (m_manual_blit == 1) {
 		if (ioctl(fbFd, FBIO_BLIT) < 0)
 			perror("FBIO_BLIT");
 	}
+#endif
 }
 
 fbClass::~fbClass()
@@ -232,6 +353,26 @@
 	}
 	else
 		locked = 1;
+
+#if defined(__sh__)
+	outcfg.outputid = STMFBIO_OUTPUTID_MAIN;
+	if (ioctl( fbFd, STMFBIO_GET_OUTPUT_CONFIG, &outcfg ) < 0)
+		perror("STMFBIO_GET_OUTPUT_CONFIG\n");
+
+	outinfo.outputid = STMFBIO_OUTPUTID_MAIN;
+	if (ioctl( fbFd, STMFBIO_GET_OUTPUTINFO, &outinfo ) < 0)
+		perror("STMFBIO_GET_OUTPUTINFO\n");
+
+	//if (ioctl( fbFd, STMFBIO_GET_VAR_SCREENINFO_EX, &infoex ) < 0)
+	//	printf("ERROR\n");
+
+	planemode.layerid = 0;
+	if (ioctl( fbFd, STMFBIO_GET_PLANEMODE, &planemode ) < 0)
+		perror("STMFBIO_GET_PLANEMODE\n");
+
+	if (ioctl( fbFd, STMFBIO_GET_VAR_SCREENINFO_EX, &infoex ) < 0)
+		perror("STMFBIO_GET_VAR_SCREENINFO_EX\n");
+#endif
 	return fbFd;
 }
 
@@ -242,25 +383,88 @@
 	if (locked == 2)  // re-enable manualBlit
 		enableManualBlit();
 	locked=0;
+
+#if defined(__sh__)
+	if (ioctl( fbFd, STMFBIO_SET_VAR_SCREENINFO_EX, &infoex ) < 0)
+		perror("STMFBIO_SET_VAR_SCREENINFO_EX\n");
+
+	if (ioctl( fbFd, STMFBIO_SET_PLANEMODE, &planemode ) < 0)
+		perror("STMFBIO_SET_PLANEMODE\n");
+
+	if (ioctl( fbFd, STMFBIO_SET_VAR_SCREENINFO_EX, &infoex ) < 0)
+		perror("STMFBIO_SET_VAR_SCREENINFO_EX\n");
+
+	if (ioctl( fbFd, STMFBIO_SET_OUTPUTINFO, &outinfo ) < 0)
+		perror("STMFBIO_SET_OUTPUTINFO\n");
+
+	if (ioctl( fbFd, STMFBIO_SET_OUTPUT_CONFIG, &outcfg ) < 0)
+		perror("STMFBIO_SET_OUTPUT_CONFIG\n");
+
+	memset(lfb, 0, stride*yRes);
+#endif
+
 	SetMode(xRes, yRes, bpp);
 	PutCMAP();
 }
 
 void fbClass::enableManualBlit()
 {
+#if not defined(__sh__)
 	unsigned char tmp = 1;
 	if (ioctl(fbFd,FBIO_SET_MANUAL_BLIT, &tmp)<0)
 		perror("FBIO_SET_MANUAL_BLIT");
 	else
 		m_manual_blit = 1;
+#endif
 }
 
 void fbClass::disableManualBlit()
 {
+#if not defined(__sh__)
 	unsigned char tmp = 0;
 	if (ioctl(fbFd,FBIO_SET_MANUAL_BLIT, &tmp)<0)
 		perror("FBIO_SET_MANUAL_BLIT");
 	else
 		m_manual_blit = 0;
+#endif
+}
+
+#if defined(__sh__)
+void fbClass::clearFBblit()
+{
+	//set real frambuffer transparent
+//	memset(lfb, 0x00, xRes * yRes * 4);
+	blit();
+}
+
+int fbClass::getFBdiff(int ret)
+{
+	if(ret == 0)
+		return topDiff;
+	else if(ret == 1)
+		return leftDiff;
+	else if(ret == 2)
+		return rightDiff;
+	else if(ret == 3)
+		return bottomDiff;
+	else
+		return -1;
 }
 
+void fbClass::setFBdiff(int top, int left, int right, int bottom)
+{
+	if(top < 0) top = 0;
+	if(top > yRes) top = yRes;
+	topDiff = top;
+	if(left < 0) left = 0;
+	if(left > xRes) left = xRes;
+	leftDiff = left;
+	if(right > 0) right = 0;
+	if(-right > xRes) right = -xRes;
+	rightDiff = right;
+	if(bottom > 0) bottom = 0;
+	if(-bottom > yRes) bottom = -yRes;
+	bottomDiff = bottom;
+}
+#endif
+
diff -Naur gui_orig/lib/gdi/fb.h gui_new/lib/gdi/fb.h
--- gui_orig/lib/gdi/fb.h	2013-05-14 22:15:18.365078812 +0200
+++ gui_new/lib/gdi/fb.h	2013-05-14 22:15:08.115955488 +0200
@@ -3,11 +3,23 @@
 
 #include <lib/base/eerror.h>
 #include <linux/fb.h>
+#if defined(__sh__)
+	#include <linux/stmfb.h>
+#endif
 
 class fbClass
 {
 	int fbFd;
 	int xRes, yRes, stride, bpp;
+#if defined(__sh__)
+	struct stmfbio_output_configuration outcfg;
+	struct stmfbio_outputinfo outinfo;
+	struct stmfbio_planeinfo planemode;
+	struct stmfbio_var_screeninfo_ex infoex;
+
+	int xResSc, yResSc;
+	int topDiff, leftDiff, rightDiff, bottomDiff;
+#endif
 	int available;
 	struct fb_var_screeninfo screeninfo;
 	fb_cmap cmap;
@@ -49,6 +61,11 @@
 	int PutCMAP();
 #endif
 	static fbClass *getInstance();
+#if defined(__sh__)
+	void clearFBblit();
+	int getFBdiff(int ret);
+	void setFBdiff(int top, int right, int left, int bottom);
+#endif
 
 	int lock();
 	void unlock();
diff -Naur gui_orig/lib/gdi/gfbdc.cpp gui_new/lib/gdi/gfbdc.cpp
--- gui_orig/lib/gdi/gfbdc.cpp	2013-05-14 22:15:18.365078812 +0200
+++ gui_new/lib/gdi/gfbdc.cpp	2013-05-14 22:15:08.115955488 +0200
@@ -171,13 +171,29 @@
 
 void gFBDC::setResolution(int xres, int yres, int bpp)
 {
+#if defined(__sh__)
+	/* if xres and yres are negative call SetMode with the lates xres and yres
+	 * we need that to read the new screen dimesnions after a resolution change
+	 * without changing the frambuffer dimensions
+	 */
+	if (xres<0 && yres<0 ) {
+		fb->SetMode(m_xres, m_yres, bpp);
+		return;
+	}
+#else
 	if (m_pixmap && (m_xres == xres) && (m_yres == yres) && (bpp == m_bpp))
 		return;
+#endif
 
 	m_xres = xres; m_yres = yres; m_bpp = bpp;
 
 	fb->SetMode(m_xres, m_yres, m_bpp);
 
+#if defined(__sh__)
+
+	for (int y = 0; y<m_yres; y++) // make whole screen transparent
+		memset(fb->lfb+y*fb->Stride(), 0x00, fb->Stride());
+#endif
 	surface.type = 0;
 	surface.x = m_xres;
 	surface.y = m_yres;
diff -Naur gui_orig/lib/gdi/gpixmap.cpp gui_new/lib/gdi/gpixmap.cpp
--- gui_orig/lib/gdi/gpixmap.cpp	2013-05-14 22:15:18.365078812 +0200
+++ gui_new/lib/gdi/gpixmap.cpp	2013-05-14 22:15:08.115955488 +0200
@@ -187,6 +187,9 @@
 			else
 				col=0x10101*color;
 			
+#if defined(__sh__)
+if ((col&0xFF000000) == 0xFF000000) col = 0xFF000000;
+#endif
 			col^=0xFF000000;
 			
 			if (surface->data_phys && gAccel::getInstance())
@@ -219,6 +222,9 @@
 			__u32 col;
 
 			col = color.argb();
+#if defined(__sh__)
+if ((col&0xFF000000) == 0xFF000000) col = 0xFF000000;
+#endif
 			col^=0xFF000000;
 
 			if (surface->data_phys && gAccel::getInstance())
@@ -400,7 +406,9 @@
 		if (flag & blitScale)
 		{
 			eWarning("unimplemented: scale on non-accel surfaces");
+#if not defined (__sh__) //if accel blit fails, do direkt blit
 			continue;
+#endif
 		}
 
 		if ((surface->bpp == 8) && (src.surface->bpp==8))
@@ -517,6 +525,9 @@
 					pal[i]=(src.surface->clut.data[i].a<<24)|(src.surface->clut.data[i].r<<16)|(src.surface->clut.data[i].g<<8)|(src.surface->clut.data[i].b);
 				else
 					pal[i]=0x010101*i;
+#if defined(__sh__)
+if ((pal[i]&0xFF000000) >= 0xE0000000) pal[i] = 0xFF000000;
+#endif
 				pal[i]^=0xFF000000;
 			}
 
diff -Naur gui_orig/lib/gdi/Makefile.inc gui_new/lib/gdi/Makefile.inc
--- gui_orig/lib/gdi/Makefile.inc	2013-05-14 22:15:18.365078812 +0200
+++ gui_new/lib/gdi/Makefile.inc	2013-05-14 22:15:08.115955488 +0200
@@ -19,7 +19,8 @@
 	gdi/lcd.cpp \
 	gdi/picexif.cpp \
 	gdi/picload.cpp \
-	gdi/region.cpp
+	gdi/region.cpp \
+	gdi/stmfb.cpp
 
 gdiincludedir = $(pkgincludedir)/lib/gdi
 gdiinclude_HEADERS = \
diff -Naur gui_orig/lib/gdi/picload.cpp gui_new/lib/gdi/picload.cpp
--- gui_orig/lib/gdi/picload.cpp	2013-05-14 22:15:18.365078812 +0200
+++ gui_new/lib/gdi/picload.cpp	2013-05-14 22:15:08.115955488 +0200
@@ -4,6 +4,7 @@
 
 #include <lib/gdi/picload.h>
 #include <lib/gdi/picexif.h>
+#include <mmeimage/libmmeimage.h>
 
 extern "C" {
 #include <jpeglib.h>
@@ -660,7 +661,45 @@
 
 void ePicLoad::decodePic()
 {
-	eDebug("[Picload] decode picture... %s",m_filepara->file);
+	if (m_filepara->id == F_JPEG)
+	{
+		eDebug("[Picload] hardware decode picture... %s",m_filepara->file);
+		m_filepara->pic_buffer = NULL;
+		FILE *fp;
+
+		if (!(fp = fopen(m_filepara->file, "rb")))
+			return; // software decode won't find the file either...
+		
+		if (get_jpeg_img_size(fp, (unsigned int *)&m_filepara->ox, (unsigned int *)&m_filepara->oy) == LIBMMEIMG_SUCCESS)
+		{
+			int imx, imy;
+
+			if ((m_conf.aspect_ratio * m_filepara->oy * m_filepara->max_x / m_filepara->ox) <= m_filepara->max_y)
+			{
+				imx = m_filepara->max_x;
+				imy = (int)(m_conf.aspect_ratio * m_filepara->oy * m_filepara->max_x / m_filepara->ox);
+			}
+			else
+			{
+				imx = (int)((1.0/m_conf.aspect_ratio) * m_filepara->ox * m_filepara->max_y / m_filepara->oy);
+				imy = m_filepara->max_y;
+			}
+			
+			if (decode_jpeg(fp, m_filepara->ox, m_filepara->oy, imx, imy, (char **)&m_filepara->pic_buffer) == LIBMMEIMG_SUCCESS)
+			{
+				m_filepara->ox = imx;
+				m_filepara->oy = imy;
+				fclose(fp);
+				return;
+			}
+		}
+		
+		eDebug("hardware decode error");
+		
+		fclose(fp);
+	}
+
+	eDebug("[Picload] software decode picture... %s",m_filepara->file);
 
 	switch(m_filepara->id)
 	{
@@ -745,12 +784,56 @@
 		}
 	}
 
-	switch(m_filepara->id)
+	int hw_decoded = 0;
+	if (m_filepara->id == F_JPEG)
 	{
-		case F_PNG:	png_load(m_filepara, m_conf.background); break;
-		case F_JPEG:	m_filepara->pic_buffer = jpeg_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy, m_filepara->max_x, m_filepara->max_y);	break;
-		case F_BMP:	m_filepara->pic_buffer = bmp_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy);	break;
-		case F_GIF:	gif_load(m_filepara); break;
+		eDebug("[Picload] hardware decode picture... %s",m_filepara->file);
+		m_filepara->pic_buffer = NULL;
+		FILE *fp;
+
+		if (!(fp = fopen(m_filepara->file, "rb")))
+			return; // software decode won't find the file either...
+		
+		if (get_jpeg_img_size(fp, (unsigned int *)&m_filepara->ox, (unsigned int *)&m_filepara->oy) == LIBMMEIMG_SUCCESS)
+		{
+			int imx, imy;
+			if (m_filepara->ox <= m_filepara->oy)
+			{
+				imy = m_conf.thumbnailsize;
+				imx = (int)( (m_conf.thumbnailsize * ((double)m_filepara->ox)) / ((double)m_filepara->oy) );
+			}
+			else
+			{
+				imx = m_conf.thumbnailsize;
+				imy = (int)( (m_conf.thumbnailsize * ((double)m_filepara->oy)) / ((double)m_filepara->ox) );
+			}
+			
+			if (decode_jpeg(fp, m_filepara->ox, m_filepara->oy, imx, imy, (char **)&m_filepara->pic_buffer) == LIBMMEIMG_SUCCESS)
+			{
+				m_filepara->ox = imx;
+				m_filepara->oy = imy;
+				fclose(fp);
+				hw_decoded = 1;
+			}
+		}
+
+		if (!hw_decoded)
+		{
+			eDebug("hardware decode error");
+		
+			fclose(fp);
+		}
+	}
+
+	if (!hw_decoded)
+	{
+		switch(m_filepara->id)
+		{
+			case F_PNG: png_load(m_filepara, m_conf.background); break;
+			case F_JPEG: m_filepara->pic_buffer = jpeg_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy, m_filepara->max_x, m_filepara->max_y); break;
+			case F_BMP: m_filepara->pic_buffer = bmp_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy); break;
+			case F_GIF: gif_load(m_filepara); break;
+		}
 	}
 
 	if(exif_thumbnail)
@@ -765,21 +848,25 @@
 				::mkdir(cachedir.c_str(), 0755);
 
 			//resize for Thumbnail
-			int imx, imy;
-			if (m_filepara->ox <= m_filepara->oy)
-			{
-				imy = m_conf.thumbnailsize;
-				imx = (int)( (m_conf.thumbnailsize * ((double)m_filepara->ox)) / ((double)m_filepara->oy) );
-			}
-			else
+			if(!hw_decoded)
 			{
-				imx = m_conf.thumbnailsize;
-				imy = (int)( (m_conf.thumbnailsize * ((double)m_filepara->oy)) / ((double)m_filepara->ox) );
-			}
+			
+				int imx, imy;
+				if (m_filepara->ox <= m_filepara->oy)
+				{
+					imy = m_conf.thumbnailsize;
+					imx = (int)( (m_conf.thumbnailsize * ((double)m_filepara->ox)) / ((double)m_filepara->oy) );
+				}
+				else
+				{
+					imx = m_conf.thumbnailsize;
+					imy = (int)( (m_conf.thumbnailsize * ((double)m_filepara->oy)) / ((double)m_filepara->ox) );
+				}
 
-			m_filepara->pic_buffer = color_resize(m_filepara->pic_buffer, m_filepara->ox, m_filepara->oy, imx, imy);
-			m_filepara->ox = imx;
-			m_filepara->oy = imy;
+				m_filepara->pic_buffer = color_resize(m_filepara->pic_buffer, m_filepara->ox, m_filepara->oy, imx, imy);
+				m_filepara->ox = imx;
+				m_filepara->oy = imy;
+			}
 
 			if(jpeg_save(cachefile.c_str(), m_filepara->ox, m_filepara->oy, m_filepara->pic_buffer))
 				eDebug("[Picload] error saving cachefile");
@@ -1207,3 +1294,65 @@
 
 	return 0;
 }
+
+#if defined(__sh__)
+//---------------------------------------------------------------------------------------------
+
+PyObject *getExif(const char *filename)
+{
+	ePyObject list;
+	Cexif exif;
+	if(exif.DecodeExif(filename))
+	{
+		if(exif.m_exifinfo->IsExif)
+		{
+			int pos=0;
+			char tmp[256];
+			list = PyList_New(22);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->Version));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->CameraMake));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->CameraModel));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->DateTime));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->Comments));
+			PyList_SET_ITEM(list, pos++,  PyString_FromFormat("%d x %d", exif.m_exifinfo->Width, exif.m_exifinfo->Height));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->Orientation));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->MeteringMode));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->ExposureProgram));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->LightSource));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->FlashUsed));
+			PyList_SET_ITEM(list, pos++,  PyString_FromFormat("%d", exif.m_exifinfo->CompressionLevel));
+			PyList_SET_ITEM(list, pos++,  PyString_FromFormat("%d", exif.m_exifinfo->ISOequivalent));
+			sprintf(tmp, "%.2f", exif.m_exifinfo->Xresolution);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.2f", exif.m_exifinfo->Yresolution);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->ResolutionUnit));
+			sprintf(tmp, "%.2f", exif.m_exifinfo->Brightness);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.5f sec.", exif.m_exifinfo->ExposureTime);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.5f", exif.m_exifinfo->ExposureBias);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.5f", exif.m_exifinfo->Distance);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.5f", exif.m_exifinfo->CCDWidth);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.2f", exif.m_exifinfo->ApertureFNumber);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+		}
+		else
+		{
+			list = PyList_New(1);
+			PyList_SET_ITEM(list, 0, PyString_FromString(exif.m_szLastError));
+		}
+		exif.ClearExif();
+	}
+	else
+	{
+		list = PyList_New(1);
+		PyList_SET_ITEM(list, 0, PyString_FromString(exif.m_szLastError));
+	}
+
+	return list ? (PyObject*)list : (PyObject*)PyList_New(0);
+}
+#endif
diff -Naur gui_orig/lib/gdi/stmfb.cpp gui_new/lib/gdi/stmfb.cpp
--- gui_orig/lib/gdi/stmfb.cpp	1970-01-01 01:00:00.000000000 +0100
+++ gui_new/lib/gdi/stmfb.cpp	2013-05-14 22:15:08.115955488 +0200
@@ -0,0 +1,75 @@
+/*
+  Interface to the Dreambox dm800/dm8000 proprietary accel interface.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <linux/fb.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <linux/stmfb.h>
+
+
+#include <lib/base/ebase.h>
+
+static int fb_fd;
+static int exec_list(void);
+
+int stmfb_accel_init(void)
+{
+	fb_fd = open("/dev/fb0", O_RDWR);
+	if (fb_fd < 0)
+	{
+		perror("/dev/fb0");
+		return 1;
+	}
+	eDebug("STMFB accel interface available\n");
+	return 0;
+}
+
+void stmfb_accel_close(void)
+{
+	close(fb_fd);
+}
+
+void stmfb_accel_blit(
+		int src_addr, int src_width, int src_height, int src_stride, int src_format,
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int src_x, int src_y, int width, int height,
+		int dst_x, int dst_y, int dwidth, int dheight)
+{
+	STMFBIO_BLT_DATA bltData;
+	memset(&bltData, 0, sizeof(STMFBIO_BLT_DATA));
+
+	bltData.operation  = BLT_OP_COPY;
+	bltData.srcOffset  = (src_addr - dst_addr) + (1920*1080*4);
+	bltData.srcPitch   = src_stride;
+	bltData.src_left   = src_x;
+	bltData.src_top    = src_y;
+	bltData.src_right  = src_x + width;
+	bltData.src_bottom = src_y + height;
+	bltData.srcFormat  = SURF_BGRA8888;
+
+	bltData.dstOffset  = 1920*1080*4;
+	bltData.dstPitch   = dst_stride;
+	bltData.dst_left   = dst_x;
+	bltData.dst_top    = dst_y;
+	bltData.dst_right  = dst_x + dwidth;
+	bltData.dst_bottom = dst_y + dheight;
+	bltData.dstFormat  = SURF_BGRA8888;
+
+	if (ioctl(fb_fd, STMFBIO_BLT, &bltData ) < 0)
+	{
+		eDebug("Error ioctl FBIO_BLIT");
+	}
+}
+
+void stmfb_accel_fill(
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int x, int y, int width, int height,
+		unsigned long color)
+{
+//	printf("unimplemented bcm_accel_fill\n");
+}
diff -Naur gui_orig/lib/python/Components/NimManager.py gui_new/lib/python/Components/NimManager.py
--- gui_orig/lib/python/Components/NimManager.py	2013-05-14 22:15:18.445087579 +0200
+++ gui_new/lib/python/Components/NimManager.py	2013-05-14 22:15:08.139958118 +0200
@@ -20,6 +20,10 @@
 import xml.etree.cElementTree
 
 def getConfigSatlist(orbpos, satlist):
+#+++>  CAUSE OF CRASH!
+	if not satlist:
+		return None
+#+++<
 	default_orbpos = None
 	for x in satlist:
 		if x[0] == orbpos:
diff -Naur gui_orig/lib/python/Makefile.inc gui_new/lib/python/Makefile.inc
--- gui_orig/lib/python/Makefile.inc	2013-05-14 22:15:18.445087579 +0200
+++ gui_new/lib/python/Makefile.inc	2013-05-14 22:15:08.139958118 +0200
@@ -22,7 +22,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/python/enigma_python.Pcpp@am__quote@
 
 .i.cpp:
-	$(AM_V_GEN)$(SWIG) $(AX_SWIG_PYTHON_OPT) -MT $@ -MD -MF $(DEPDIR)/$*.Tpo -I$(top_srcdir) -O -nortti -nothreads -o $@ $<
+	$(AM_V_GEN)$(SWIG) $(AX_SWIG_PYTHON_OPT) -MT $@ -MD -MF $(DEPDIR)/$*.Tpo -I$(top_srcdir) -D__sh__ -O -nortti -nothreads -o $@ $<
 	$(AM_V_at)mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Pcpp
 	$(AM_V_at)$(PYTHON) $(srcdir)/python/enigma_py_patcher.py python/enigma.py
 
diff -Naur gui_orig/lib/python/Plugins/SystemPlugins/HdmiCEC/plugin.py gui_new/lib/python/Plugins/SystemPlugins/HdmiCEC/plugin.py
--- gui_orig/lib/python/Plugins/SystemPlugins/HdmiCEC/plugin.py	2013-05-14 22:15:18.381080567 +0200
+++ gui_new/lib/python/Plugins/SystemPlugins/HdmiCEC/plugin.py	2013-05-14 22:15:08.123956364 +0200
@@ -105,7 +105,7 @@
 
 def Plugins(**kwargs):
 	from os import path
-	if path.exists("/dev/hdmi_cec") or path.exists("/dev/misc/hdmi_cec0"):
+	if path.exists("/dev/hdmi_cec") or path.exists("/lib/modules/cec.ko"):
 		import Components.HdmiCec
 		from Plugins.Plugin import PluginDescriptor
 		return [PluginDescriptor(name = "HDMI CEC setup", description = _("Adjust HDMI CEC settings"), where = PluginDescriptor.WHERE_PLUGINMENU, fnc = main)]
diff -Naur gui_orig/lib/python/Plugins/SystemPlugins/Hotplug/plugin.py gui_new/lib/python/Plugins/SystemPlugins/Hotplug/plugin.py
--- gui_orig/lib/python/Plugins/SystemPlugins/Hotplug/plugin.py	2013-05-14 22:15:18.389081439 +0200
+++ gui_new/lib/python/Plugins/SystemPlugins/Hotplug/plugin.py	2013-05-14 22:15:08.127956803 +0200
@@ -9,6 +9,8 @@
 	action = v.get("ACTION")
 	device = v.get("DEVPATH")
 	physdevpath = v.get("PHYSDEVPATH")
+	if physdevpath == "-":
+		physdevpath = None
 	media_state = v.get("X_E2_MEDIA_STATUS")
 
 	dev = device.split('/')[-1]
diff -Naur gui_orig/lib/python/Plugins/SystemPlugins/Videomode/plugin.py gui_new/lib/python/Plugins/SystemPlugins/Videomode/plugin.py
--- gui_orig/lib/python/Plugins/SystemPlugins/Videomode/plugin.py	2013-05-14 22:15:18.381080567 +0200
+++ gui_new/lib/python/Plugins/SystemPlugins/Videomode/plugin.py	2013-05-14 22:15:08.123956364 +0200
@@ -67,6 +67,9 @@
 				self.list.append(getConfigListEntry(_("Resolution"), config.av.videorate[config.av.videomode[config.av.videoport.value].value], _("Configure the screen resolution in PC output mode.")))
 			else:
 				self.list.append(getConfigListEntry(_("Refresh rate"), config.av.videorate[config.av.videomode[config.av.videoport.value].value], _("Configure the refresh rate of the screen.")))
+#+++>
+		self.list.append(getConfigListEntry(_("3D Mode"), config.av.threedmode))
+#+++<
 
 		port = config.av.videoport.value
 		if port not in config.av.videomode:
@@ -90,6 +93,14 @@
 
 #		if config.av.videoport.value == "DVI":
 #			self.list.append(getConfigListEntry(_("Allow Unsupported Modes"), config.av.edid_override))
+#+++>
+		if config.av.videoport.value == "Component":
+			self.list.append(getConfigListEntry(_("Color Format"), config.av.colorformat_yuv))
+
+		if config.av.videoport.value == "HDMI":
+			self.list.append(getConfigListEntry(_("Color Format"), config.av.colorformat_hdmi))
+			self.list.append(getConfigListEntry(_("Audio Source"), config.av.hdmi_audio_source))
+#+++<
 		if config.av.videoport.value == "Scart":
 			self.list.append(getConfigListEntry(_("Color format"), config.av.colorformat, _("Configure which color format should be used on the SCART output.")))
 			if level >= 1:
diff -Naur gui_orig/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py gui_new/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py
--- gui_orig/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py	2013-05-14 22:15:18.381080567 +0200
+++ gui_new/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py	2013-05-14 22:15:08.119955926 +0200
@@ -14,56 +14,38 @@
 	hw_type = HardwareInfo().get_device_name()
 	modes = { }  # a list of (high-level) modes for a certain port.
 
-	rates["PAL"] =			{ "50Hz":	{ 50: "pal" },
-								"60Hz":		{ 60: "pal60" },
-								"multi":	{ 50: "pal", 60: "pal60" } }
+	rates["PAL"] =			{ "50Hz":	{ 50: "pal" } }
 
-	rates["NTSC"] =			{ "60Hz": 	{ 60: "ntsc" } }
+	rates["576i"] =			{ "50Hz":	{ 50: "576i50" } }
 
-	rates["Multi"] =		{ "multi": 	{ 50: "pal", 60: "ntsc" } }
-
-	rates["480i"] =			{ "60Hz": 	{ 60: "480i" } }
-
-	rates["576i"] =			{ "50Hz": 	{ 50: "576i" } }
-
-	rates["480p"] =			{ "60Hz": 	{ 60: "480p" } }
-
-	rates["576p"] =			{ "50Hz": 	{ 50: "576p" } }
-
-	rates["720p"] =			{ "50Hz": 	{ 50: "720p50" },
-								"60Hz": 	{ 60: "720p" },
-								"multi": 	{ 50: "720p50", 60: "720p" } }
+	rates["576p"] =			{ "50Hz":	{ 50: "576p50" } }
 
+	rates["720p"] =			{ "50Hz":	{ 50: "720p50" },
+								"60Hz":	{ 60: "720p60" } }
+ 
 	rates["1080i"] =		{ "50Hz":	{ 50: "1080i50" },
 								"60Hz":		{ 60: "1080i" },
 								"multi":	{ 50: "1080i50", 60: "1080i" } }
 
-	rates["1080p"] =		{ "50Hz":	{ 50: "1080p50" },
-								"60Hz":		{ 60: "1080p" },
-								"multi":	{ 50: "1080p50", 60: "1080p" } }
+	rates["1080p"] =		{ "23Hz":	{ 50: "1080p23" },
+								"24Hz":	{ 60: "1080p24" },
+								"25Hz":	{ 60: "1080p25" },
+								"29Hz":	{ 60: "1080p29" },
+								"30Hz":	{ 60: "1080p30" },
+								"50Hz":	{ 60: "1080p50" } }
 
 	rates["PC"] = {
-		"1024x768": { 60: "1024x768" }, # not possible on DM7025
-		"800x600" : { 60: "800x600" },  # also not possible
-		"720x480" : { 60: "720x480" },
-		"720x576" : { 60: "720x576" },
-		"1280x720": { 60: "1280x720" },
-		"1280x720 multi": { 50: "1280x720_50", 60: "1280x720" },
-		"1920x1080": { 60: "1920x1080"},
-		"1920x1080 multi": { 50: "1920x1080", 60: "1920x1080_50" },
-		"1280x1024" : { 60: "1280x1024"},
-		"1366x768" : { 60: "1366x768"},
-		"1366x768 multi" : { 50: "1366x768", 60: "1366x768_50" },
-		"1280x768": { 60: "1280x768" },
-		"640x480" : { 60: "640x480" }
+		"1024x768"  : { 60: "1024x768_60", 70: "1024x768_70", 75: "1024x768_75", 90: "1024x768_90", 100: "1024x768_100" }, #43 60 70 72 75 90 100
+		"1280x1024" : { 60: "1280x1024_60", 70: "1280x1024_70", 75: "1280x1024_75" }, #43 47 60 70 74 75
+		"1600x1200" : { 60: "1600x1200_60" }, #60 66 76
 	}
 
-	modes["Scart"] = ["PAL", "NTSC", "Multi"]
-	modes["YPbPr"] = ["720p", "1080i", "576p", "480p", "576i", "480i"]
+	modes["Scart"] = ["PAL"]
+	modes["Component"] = ["720p", "1080p", "1080i", "576p", "576i"]
         if hw_type == "me" or hw_type == "minime" :
 		config.av.edid_override = True
-	modes["DVI"] = ["720p", "1080p", "1080i", "576p", "480p", "576i", "480i"]
-	modes["DVI-PC"] = ["PC"]
+	modes["HDMI"] = ["720p", "1080p", "1080i", "576p", "576i"]
+	modes["HDMI-PC"] = ["PC"]
 
 	def getOutputAspect(self):
 		ret = (16,9)
@@ -114,14 +96,14 @@
 		portlist = self.getPortList()
 		has1080p50 = False
 		for port in portlist:
-			if port == 'DVI' and HardwareInfo().has_hdmi():
+			if port == 'HDMI' and HardwareInfo().has_hdmi():
 				if "1080p50" in self.modes_available:
 					has1080p50 = True
 
 		if has1080p50:
-			self.widescreen_modes = set(["720p", "1080i", "1080p"])
+			self.widescreen_modes = set(["576i", "576p", "720p", "1080i", "1080p"])
 		else:
-			self.widescreen_modes = set(["720p", "1080i"])
+			self.widescreen_modes = set(["576i", "576p", "720p", "1080i"])
 
 		# take over old AVSwitch component :)
 		from Components.AVSwitch import AVSwitch
@@ -130,6 +112,16 @@
 		config.av.wss.notifiers = [ ]
 		AVSwitch.getOutputAspect = self.getOutputAspect
 
+#+++>
+		config.av.colorformat_hdmi = ConfigSelection(choices = {"hdmi_rgb": _("RGB"), "hdmi_yuv": _("YUV"), "hdmi_422": _("422")}, default="hdmi_rgb")
+		config.av.colorformat_yuv = ConfigSelection(choices = {"yuv": _("YUV")}, default="yuv")
+		config.av.hdmi_audio_source = ConfigSelection(choices = {"pcm": _("PCM"), "spdif": _("SPDIF")}, default="pcm")
+		config.av.threedmode = ConfigSelection(choices = {"off": _("Off"), "sbs": _("Side by Side"),"tab": _("Top and Bottom")}, default="off")
+		config.av.threedmode.addNotifier(self.set3DMode)
+		config.av.colorformat_hdmi.addNotifier(self.setHDMIColor)
+		config.av.colorformat_yuv.addNotifier(self.setYUVColor)
+		config.av.hdmi_audio_source.addNotifier(self.setHDMIAudioSource)
+#+++<
 		config.av.aspect.addNotifier(self.updateAspect)
 		config.av.wss.addNotifier(self.updateAspect)
 		config.av.policy_169.addNotifier(self.updateAspect)
@@ -161,6 +153,8 @@
 	def isModeAvailable(self, port, mode, rate):
 		rate = self.rates[mode][rate]
 		for mode in rate.values():
+			if port == "HDMI-PC":
+				return True
 			if mode not in self.modes_available:
 				return False
 		return True
@@ -197,7 +191,12 @@
 		except IOError:
 			print "writing initial videomode to /etc/videomode failed."
 
+		#call setResolution() with -1,-1 to read the new scrren dimesions without changing the framebuffer resolution
+		from enigma import gMainDC
+		gMainDC.getInstance().setResolution(-1, -1)
+
 		self.updateAspect(None)
+		self.updateColor(port)
 
 	def saveMode(self, port, mode, rate):
 		print "saveMode", port, mode, rate
@@ -215,7 +214,8 @@
 		return True
 
 	def isPortUsed(self, port):
-		if port == "DVI":
+#		if port == "DVI":
+		if port == "HDMI":
 			self.readPreferredModes()
 			return len(self.modes_preferred) != 0
 		else:
@@ -349,6 +349,33 @@
 		except IOError:
 			pass
 
+#+++>
+	def set3DMode(self, configElement):
+		open("/proc/stb/video/3d_mode", "w").write(configElement.value)
+
+	def setHDMIColor(self, configElement):
+		map = {"hdmi_rgb": 0, "hdmi_yuv": 1, "hdmi_422": 2}
+		open("/proc/stb/avs/0/colorformat", "w").write(configElement.value)
+
+	def setYUVColor(self, configElement):
+		map = {"yuv": 0}
+		open("/proc/stb/avs/0/colorformat", "w").write(configElement.value)
+
+	def setHDMIAudioSource(self, configElement):
+		open("/proc/stb/hdmi/audio_source", "w").write(configElement.value)
+
+	def updateColor(self, port):
+		print "updateColor: ", port
+		if port == "HDMI":
+			self.setHDMIColor(config.av.colorformat_hdmi)
+		elif port == "Component":
+			self.setYUVColor(config.av.colorformat_yuv)
+		elif port == "Scart":
+			map = {"cvbs": 0, "rgb": 1, "svideo": 2, "yuv": 3}
+			from enigma import eAVSwitch
+			eAVSwitch.getInstance().setColorFormat(map[config.av.colorformat.value])
+#+++<
+
 config.av.edid_override = ConfigYesNo(default = False)
 video_hw = VideoHardware()
 video_hw.setConfiguredMode()
diff -Naur gui_orig/lib/python/Tools/KeyBindings.py gui_new/lib/python/Tools/KeyBindings.py
--- gui_orig/lib/python/Tools/KeyBindings.py	2013-05-14 22:15:18.445087579 +0200
+++ gui_new/lib/python/Tools/KeyBindings.py	2013-05-14 22:15:08.143958557 +0200
@@ -45,7 +45,10 @@
 		KEYIDS["KEY_9"]: ("9",),
 		KEYIDS["KEY_EXIT"]: ("EXIT",),
 		KEYIDS["KEY_STOP"]: ("STOP",),
-		KEYIDS["KEY_RECORD"]: ("RECORD",)
+		KEYIDS["KEY_RECORD"]: ("RECORD",),
+		KEYIDS["KEY_EPG"]: ("EPG",),
+		KEYIDS["KEY_REWIND"]: ("REWIND",),
+		KEYIDS["KEY_FASTFORWARD"]: ("FASTFORWARD",)
 	},
 	{
 		KEYIDS["BTN_0"]: ("UP", "fp"),
@@ -87,7 +90,10 @@
 		KEYIDS["KEY_9"]: ("9",),
 		KEYIDS["KEY_EXIT"]: ("EXIT",),
 		KEYIDS["KEY_STOP"]: ("TV", "SHIFT"),
-		KEYIDS["KEY_RECORD"]: ("RADIO", "SHIFT")
+		KEYIDS["KEY_RECORD"]: ("RADIO", "SHIFT"),
+		KEYIDS["KEY_EPG"]: ("EPG",),
+		KEYIDS["KEY_REWIND"]: ("REWIND",),
+		KEYIDS["KEY_FASTFORWARD"]: ("FASTFORWARD",)
 	},
 	{
 		KEYIDS["BTN_0"]: ("UP", "fp"),
diff -Naur gui_orig/lib/service/servicedvb.cpp gui_new/lib/service/servicedvb.cpp
--- gui_orig/lib/service/servicedvb.cpp	2013-05-14 22:15:18.457088896 +0200
+++ gui_new/lib/service/servicedvb.cpp	2013-05-14 22:15:08.147958995 +0200
@@ -579,6 +579,9 @@
 	if (sc)
 	{
 		std::list<std::string> extensions;
+#if defined(__sh__) //Topfield original recording extension
+		extensions.push_back("rec");
+#endif
 		extensions.push_back("ts");
 		extensions.push_back("trp");
 		sc->addServiceFactory(eServiceFactoryDVB::id, this, extensions);
diff -Naur gui_orig/lib/service/servicedvbrecord.cpp gui_new/lib/service/servicedvbrecord.cpp
--- gui_orig/lib/service/servicedvbrecord.cpp	2013-05-14 22:15:18.457088896 +0200
+++ gui_new/lib/service/servicedvbrecord.cpp	2013-05-14 22:15:08.147958995 +0200
@@ -10,6 +10,10 @@
 #include <netinet/in.h>
 
 
+#if defined(__sh__)
+#include <sys/vfs.h>
+#include <linux/magic.h>
+#endif
 DEFINE_REF(eDVBServiceRecord);
 
 eDVBServiceRecord::eDVBServiceRecord(const eServiceReferenceDVB &ref, bool isstreamclient): m_ref(ref)
@@ -299,9 +303,43 @@
 	
 	if (!m_record && m_tuned && !m_streaming && !m_simulate)
 	{
+#if defined(__sh__)
+		int flags = O_WRONLY|O_CREAT|O_LARGEFILE;
+		struct statfs sbuf;
+#endif
 		eDebug("Recording to %s...", m_filename.c_str());
 		::remove(m_filename.c_str());
+#if defined(__sh__)
+		//we must creat a file for statfs
 		int fd = ::open(m_filename.c_str(), O_WRONLY|O_CREAT|O_LARGEFILE, 0666);
+		::close(fd);
+		if (statfs(m_filename.c_str(), &sbuf) < 0)
+		{
+			eDebug("eDVBServiceRecord - can't get fs type assuming none NFS!");
+		} else
+		{
+			if (sbuf.f_type == EXT3_SUPER_MAGIC)
+				eDebug("eDVBServiceRecord - Ext2/3/4 Filesystem\n");
+			else
+			if (sbuf.f_type == NFS_SUPER_MAGIC)
+			{
+				eDebug("eDVBServiceRecord - NFS Filesystem; add O_DIRECT to flags\n");
+				flags |= O_DIRECT;
+			}
+			else
+			if (sbuf.f_type == USBDEVICE_SUPER_MAGIC)
+				eDebug("eDVBServiceRecord - USB Device\n");
+			else
+			if (sbuf.f_type == SMB_SUPER_MAGIC)
+				eDebug("eDVBServiceRecord - SMBs Device\n");
+			else 
+			if (sbuf.f_type == MSDOS_SUPER_MAGIC)
+				eDebug("eDVBServiceRecord - MSDOS Device\n");
+		}
+		fd = ::open(m_filename.c_str(), flags, 0644);
+#else
+		int fd = ::open(m_filename.c_str(), O_WRONLY|O_CREAT|O_LARGEFILE, 0644);
+#endif
 		if (fd == -1)
 		{
 			eDebug("eDVBServiceRecord - can't open recording file!");
diff -Naur gui_orig/lib/service/servicemp3.cpp gui_new/lib/service/servicemp3.cpp
--- gui_orig/lib/service/servicemp3.cpp	2013-05-14 22:15:18.457088896 +0200
+++ gui_new/lib/service/servicemp3.cpp	2013-05-14 22:15:08.151959433 +0200
@@ -73,7 +73,24 @@
 		extensions.push_back("3gp");
 		extensions.push_back("3g2");
 		extensions.push_back("asf");
-		extensions.push_back("wmv");
+#if defined(__sh__)
+		extensions.push_back("mpeg");
+		extensions.push_back("m2ts");
+		extensions.push_back("trp");
+		extensions.push_back("vdr");
+		extensions.push_back("mts");
+		extensions.push_back("rar");
+		extensions.push_back("img");
+		extensions.push_back("iso");
+		extensions.push_back("ifo");
+		int fd = open("/proc/stb/info/model", O_RDONLY);
+		char tmp[255];
+		int rd = fd >= 0 ? read(fd, tmp, 255) : 0;
+		if (fd >= 0)
+			close(fd);
+		if (!strncmp(tmp, "ufs912\n", rd) || !strncmp(tmp, "ufs913\n", rd) || !strncmp(tmp, "atevio7500\n", rd) || !strncmp(tmp, "hs7110\n", rd) || !strncmp(tmp, "hs7810a\n", rd) || !strncmp(tmp, "spark7162\n", rd) || !strncmp(tmp, "whitebox\n", rd))
+			extensions.push_back("wmv");
+#endif
 		extensions.push_back("wma");
 		sc->addServiceFactory(eServiceFactoryMP3::id, this, extensions);
 	}
@@ -848,7 +865,9 @@
 	case sTagKeywords:
 	case sTagChannelMode:
 	case sUser+12:
+#if not defined(__sh__)
 		return resIsString;
+#endif
 	case sTagTrackGain:
 	case sTagTrackPeak:
 	case sTagAlbumGain:
diff -Naur gui_orig/main/Makefile.am gui_new/main/Makefile.am
--- gui_orig/main/Makefile.am	2013-05-14 22:15:18.289070501 +0200
+++ gui_new/main/Makefile.am	2013-05-14 22:15:07.663905970 +0200
@@ -51,7 +51,8 @@
 	@PTHREAD_LIBS@ \
 	@PYTHON_LDFLAGS@ \
 	@LIBDDVD_LIBS@ \
-	-ltuxtxt -ltuxtxt32bpp -lcrypt
+	-ltuxtxt -ltuxtxt32bpp -lcrypt \
+	-ldl -lpthread -lcrypt -lresolv -lrt -lmmeimage
 
 enigma2_LDFLAGS = -Wl,--export-dynamic

diff -Naur enigma2_orig/lib/driver/vfd.cpp enigma2/lib/driver/vfd.cpp
--- enigma2_orig/lib/driver/vfd.cpp	2013-05-03 16:44:53.532546355 +0200
+++ enigma2/lib/driver/vfd.cpp	2013-06-08 08:09:10.039292326 +0200
@@ -7,14 +7,28 @@
 #include <sys/ioctl.h>
 #include <ctype.h>
 #include <sys/stat.h>
-#include  <pthread.h> 
+#include <pthread.h>
 
 #include <lib/base/eerror.h>
 #include <lib/driver/vfd.h>
 
-#if defined(HAVE_GIGABLUE_TEXTLCD)
-#define VFD_DEVICE "/proc/vfd"
-#endif
+#define VFDLENGTH 16
+#define VFD_DEVICE "/dev/vfd"
+#define VFDICONDISPLAYONOFF   0xc0425a0a
+#define VFDDISPLAYCHARS       0xc0425a00
+#define VFDBRIGHTNESS         0xc0425a03
+#define VFDDISPLAYWRITEONOFF  0xc0425a05 //light on off
+#define VFDSETTIME2           0xc0425afd
+
+static pthread_t thread_start_loop = 0;
+void * start_loop (void *arg);
+
+struct vfd_ioctl_data
+{
+	unsigned char start;
+	unsigned char data[64];
+	unsigned char length;
+};
 
 evfd* evfd::instance = NULL;
 
@@ -27,88 +41,142 @@
 
 evfd::evfd()
 {
-#if defined(HAVE_GIGABLUE_TEXTLCD)
 	file_vfd = 0;
-#endif
 }
 
+void evfd::init()
+{
+	pthread_create (&thread_start_loop, NULL, &start_loop, NULL);
+	return;
+}
+
+evfd::~evfd()
+{
+	//close (file_vfd);
+}
 
-int vfd_init( void )
+void * start_loop (void *arg)
 {
 	evfd vfd;
-#if defined(HAVE_GIGABLUE_TEXTLCD)
-	vfd.vfd_led("1");
-	char str[]="RED";
-#elif defined(HAVE_VENTON_TEXTLCD)
-	vfd.vfd_symbol_network(0);
-	vfd.vfd_symbol_circle(0);
-#endif
-	return 0;
+	//vfd.vfd_clear_icons();
+	vfd.vfd_write_string("Opensif Spark");
+	//run 2 times through all icons 
+	for (int vloop = 0; vloop < 128; vloop++)
+	{
+		if (vloop%14 == 0 )
+			vfd.vfd_set_brightness(1);
+		else if (vloop%14 == 1 )
+			vfd.vfd_set_brightness(2);
+		else if (vloop%14 == 2 )
+			vfd.vfd_set_brightness(3);
+		else if (vloop%14 == 3 )
+			vfd.vfd_set_brightness(4);
+		else if (vloop%14 == 4 )
+			vfd.vfd_set_brightness(5);
+		else if (vloop%14 == 5 )
+			vfd.vfd_set_brightness(6);
+		else if (vloop%14 == 6 )
+			vfd.vfd_set_brightness(7);
+		else if (vloop%14 == 7 )
+			vfd.vfd_set_brightness(6);
+		else if (vloop%14 == 8 )
+			vfd.vfd_set_brightness(5);
+		else if (vloop%14 == 9 )
+			vfd.vfd_set_brightness(4);
+		else if (vloop%14 == 10 )
+			vfd.vfd_set_brightness(3);
+		else if (vloop%14 == 11 )
+			vfd.vfd_set_brightness(2);
+		else if (vloop%14 == 12 )
+			vfd.vfd_set_brightness(1);
+		else if (vloop%14 == 13 )
+			vfd.vfd_set_brightness(0);
+		usleep(75000);
+	}
+	vfd.vfd_set_brightness(7);
+	return NULL;
 }
 
-void evfd::init()
+void evfd::vfd_write_string(char * str)
 {
-	vfd_init();
+	int i;
+	i = strlen ( str );
+	if ( i > 63 ) i = 63;
+	struct vfd_ioctl_data data;
+	memset ( data.data, ' ', 63 );
+	memcpy ( data.data, str, i );
+	data.start = 0;
+	data.length = i;
+	file_vfd = open (VFD_DEVICE, O_WRONLY);
+	ioctl ( file_vfd, VFDDISPLAYCHARS, &data );
+	close (file_vfd);
 	return;
 }
 
-evfd::~evfd()
+void evfd::vfd_clear_string()
 {
+	vfd_write_string("                ");
+	return;
 }
 
-void evfd::vfd_led(char * led)
+void evfd::vfd_set_icon(tvfd_icon id, bool onoff)
 {
-#if defined(HAVE_GIGABLUE_TEXTLCD)
-	FILE *f;
-	if((f = fopen("/proc/stb/fp/led0_pattern","w")) == NULL) {
-		eDebug("cannot open /proc/stb/fp/led0_pattern (%m)");
-		return;
-	}
-	
-	fprintf(f,"%s", led);
-	fclose(f);
-#endif
+	struct vfd_ioctl_data data;
+	memset(&data, 0, sizeof(struct vfd_ioctl_data));
+	data.start = 0x00;
+	data.data[0] = id;
+	data.data[4] = onoff;
+	data.length = 5;
+	file_vfd = open (VFD_DEVICE, O_WRONLY);
+	ioctl(file_vfd, VFDICONDISPLAYONOFF, &data);
+	close (file_vfd);
+	return;
 }
 
-void evfd::vfd_write_string(char * str)
+void evfd::vfd_clear_icons()
 {
-#if defined(HAVE_GIGABLUE_TEXTLCD)
-	FILE *f;
-	if((f = fopen("/proc/vfd","w")) == NULL) {
-		eDebug("cannotopen /proc/vfd (%m)");
-	
-		return;
+	for (int id = 0x10; id < 0x20; id++)
+	{
+		vfd_set_icon((tvfd_icon)id, false);
 	}
-	
-	fprintf(f,"%s", str);
-	fclose(f);
-#endif
+	return;
 }
 
-void evfd::vfd_symbol_network(int net)
-{
-#if defined(HAVE_VENTON_TEXTLCD)
-	FILE *f;
-	if((f = fopen("/proc/stb/lcd/symbol_network","w")) == NULL) {
-		eDebug("cannot open /proc/stb/lcd/symbol_network (%m)");
-		return;
-	}
-	
-	fprintf(f,"%i", net);
-	fclose(f);
-#endif
+void evfd::vfd_set_brightness(unsigned char setting)
+{
+	struct vfd_ioctl_data data;
+	memset(&data, 0, sizeof(struct vfd_ioctl_data));
+	data.start = setting & 0x07;
+	data.length = 0;
+	file_vfd = open (VFD_DEVICE, O_WRONLY);
+	ioctl ( file_vfd, VFDBRIGHTNESS, &data );
+	close (file_vfd);
+	return;
 }
 
-void evfd::vfd_symbol_circle(int cir)
-{
-#if defined(HAVE_VENTON_TEXTLCD)
-	FILE *f;
-	if((f = fopen("/proc/stb/lcd/symbol_circle","w")) == NULL) {
-		eDebug("cannotopen /proc/stb/lcd/symbol_circle (%m)");
-		return;
-	}
-	
-	fprintf(f,"%i", cir);
-	fclose(f);
-#endif
+void evfd::vfd_set_light(bool onoff)
+{
+	struct vfd_ioctl_data data;
+	memset(&data, 0, sizeof(struct vfd_ioctl_data));
+	if (onoff)
+		data.start = 0x01;
+	else
+		data.start = 0x00;
+	data.length = 0;
+	file_vfd = open (VFD_DEVICE, O_WRONLY);
+	ioctl(file_vfd, VFDDISPLAYWRITEONOFF, &data);
+	close (file_vfd);
+	return;
 }
+
+void evfd::vfd_set_clock(time_t t)
+{
+	struct tm *tmp;
+	tmp = localtime(&t);
+	t += tmp->tm_gmtoff;
+	file_vfd = open (VFD_DEVICE, O_WRONLY);
+	ioctl(file_vfd, VFDSETTIME2, &t);
+	close (file_vfd);
+	return;
+}
+
diff -Naur enigma2_orig/lib/driver/vfd.h enigma2/lib/driver/vfd.h
--- enigma2_orig/lib/driver/vfd.h	2013-05-03 16:44:53.532546355 +0200
+++ enigma2/lib/driver/vfd.h	2013-06-08 08:09:10.039292326 +0200
@@ -1,13 +1,13 @@
 #ifndef VFD_H_
 #define VFD_H_
 
+typedef enum { VFD_USB = 0x10, VFD_STANDBY, VFD_SAT, VFD_REC, VFD_TIMESHIFT, VFD_TIMER, VFD_HD, VFD_LOCK, VFD_DD, VFD_MUTE, VFD_TUNER1, VFD_TUNER2, VFD_MP3, VFD_REPEAT, VFD_PLAY, VFD_PAUSE, VFD_TER, VFD_FILE, VFD_480i, VFD_480p, VFD_576i, VFD_576p, VFD_720p, VFD_1080i, VFD_1080p } tvfd_icon;
+
 class evfd
 {
 protected:
 	static evfd *instance;
-#if defined(HAVE_GIGABLUE_TEXTLCD)
 	int file_vfd;
-#endif
 #ifdef SWIG
 	evfd();
 	~evfd();
@@ -20,11 +20,17 @@
 	void init();
 	static evfd* getInstance();
 
+	void vfd_set_icon(tvfd_icon id, bool onoff);
+	void vfd_clear_icons();
+
 	void vfd_write_string(char * string);
-	void vfd_led(char * led);
-	void vfd_symbol_network(int net);
-	void vfd_symbol_circle(int cir);
-};
+	void vfd_clear_string();
+	
+	void vfd_set_brightness(unsigned char setting);
+	void vfd_set_light(bool onoff);
+
+	void vfd_set_clock(time_t t);
 
+};
 
 #endif


